// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: overload.proto

package overload

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Job struct {
	Id                   int32         `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TestStart            float64       `protobuf:"fixed64,2,opt,name=test_start,json=testStart,proto3" json:"test_start,omitempty"`
	TestStop             float64       `protobuf:"fixed64,3,opt,name=test_stop,json=testStop,proto3" json:"test_stop,omitempty"`
	Config               string        `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	Author               string        `protobuf:"bytes,5,opt,name=author,proto3" json:"author,omitempty"`
	RegressionId         string        `protobuf:"bytes,6,opt,name=regression_id,json=regressionId,proto3" json:"regression_id,omitempty"`
	Description          string        `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	Tank                 string        `protobuf:"bytes,8,opt,name=tank,proto3" json:"tank,omitempty"`
	Target               string        `protobuf:"bytes,9,opt,name=target,proto3" json:"target,omitempty"`
	EnvironmentDetails   string        `protobuf:"bytes,10,opt,name=environment_details,json=environmentDetails,proto3" json:"environment_details,omitempty"`
	Status               string        `protobuf:"bytes,11,opt,name=status,proto3" json:"status,omitempty"`
	AutostopTime         float64       `protobuf:"fixed64,12,opt,name=autostop_time,json=autostopTime,proto3" json:"autostop_time,omitempty"`
	AutostopMessage      string        `protobuf:"bytes,13,opt,name=autostop_message,json=autostopMessage,proto3" json:"autostop_message,omitempty"`
	Imbalance            int32         `protobuf:"varint,14,opt,name=imbalance,proto3" json:"imbalance,omitempty"`
	Collections          []*Collection `protobuf:"bytes,15,rep,name=collections,proto3" json:"collections,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{0}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Job.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(dst, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Job) GetTestStart() float64 {
	if m != nil {
		return m.TestStart
	}
	return 0
}

func (m *Job) GetTestStop() float64 {
	if m != nil {
		return m.TestStop
	}
	return 0
}

func (m *Job) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

func (m *Job) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Job) GetRegressionId() string {
	if m != nil {
		return m.RegressionId
	}
	return ""
}

func (m *Job) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Job) GetTank() string {
	if m != nil {
		return m.Tank
	}
	return ""
}

func (m *Job) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *Job) GetEnvironmentDetails() string {
	if m != nil {
		return m.EnvironmentDetails
	}
	return ""
}

func (m *Job) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Job) GetAutostopTime() float64 {
	if m != nil {
		return m.AutostopTime
	}
	return 0
}

func (m *Job) GetAutostopMessage() string {
	if m != nil {
		return m.AutostopMessage
	}
	return ""
}

func (m *Job) GetImbalance() int32 {
	if m != nil {
		return m.Imbalance
	}
	return 0
}

func (m *Job) GetCollections() []*Collection {
	if m != nil {
		return m.Collections
	}
	return nil
}

type Collection struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Env                  string   `protobuf:"bytes,2,opt,name=env,proto3" json:"env,omitempty"`
	Project              string   `protobuf:"bytes,3,opt,name=project,proto3" json:"project,omitempty"`
	Service              string   `protobuf:"bytes,4,opt,name=service,proto3" json:"service,omitempty"`
	Ref                  string   `protobuf:"bytes,5,opt,name=ref,proto3" json:"ref,omitempty"`
	Name                 string   `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	Author               string   `protobuf:"bytes,7,opt,name=author,proto3" json:"author,omitempty"`
	Type                 string   `protobuf:"bytes,8,opt,name=type,proto3" json:"type,omitempty"`
	LatestJobs           []*Job   `protobuf:"bytes,9,rep,name=latestJobs,proto3" json:"latestJobs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Collection) Reset()         { *m = Collection{} }
func (m *Collection) String() string { return proto.CompactTextString(m) }
func (*Collection) ProtoMessage()    {}
func (*Collection) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{1}
}
func (m *Collection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Collection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Collection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Collection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Collection.Merge(dst, src)
}
func (m *Collection) XXX_Size() int {
	return m.Size()
}
func (m *Collection) XXX_DiscardUnknown() {
	xxx_messageInfo_Collection.DiscardUnknown(m)
}

var xxx_messageInfo_Collection proto.InternalMessageInfo

func (m *Collection) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Collection) GetEnv() string {
	if m != nil {
		return m.Env
	}
	return ""
}

func (m *Collection) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *Collection) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *Collection) GetRef() string {
	if m != nil {
		return m.Ref
	}
	return ""
}

func (m *Collection) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Collection) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Collection) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Collection) GetLatestJobs() []*Job {
	if m != nil {
		return m.LatestJobs
	}
	return nil
}

type CreateJobRequest struct {
	TestStart            float64       `protobuf:"fixed64,1,opt,name=test_start,json=testStart,proto3" json:"test_start,omitempty"`
	TestStop             float64       `protobuf:"fixed64,2,opt,name=test_stop,json=testStop,proto3" json:"test_stop,omitempty"`
	Config               string        `protobuf:"bytes,3,opt,name=config,proto3" json:"config,omitempty"`
	Author               string        `protobuf:"bytes,4,opt,name=author,proto3" json:"author,omitempty"`
	RegressionId         string        `protobuf:"bytes,5,opt,name=regression_id,json=regressionId,proto3" json:"regression_id,omitempty"`
	Description          string        `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	Tank                 string        `protobuf:"bytes,7,opt,name=tank,proto3" json:"tank,omitempty"`
	Target               string        `protobuf:"bytes,8,opt,name=target,proto3" json:"target,omitempty"`
	EnvironmentDetails   string        `protobuf:"bytes,9,opt,name=environment_details,json=environmentDetails,proto3" json:"environment_details,omitempty"`
	Collections          []*Collection `protobuf:"bytes,10,rep,name=collections,proto3" json:"collections,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CreateJobRequest) Reset()         { *m = CreateJobRequest{} }
func (m *CreateJobRequest) String() string { return proto.CompactTextString(m) }
func (*CreateJobRequest) ProtoMessage()    {}
func (*CreateJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{2}
}
func (m *CreateJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJobRequest.Merge(dst, src)
}
func (m *CreateJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJobRequest proto.InternalMessageInfo

func (m *CreateJobRequest) GetTestStart() float64 {
	if m != nil {
		return m.TestStart
	}
	return 0
}

func (m *CreateJobRequest) GetTestStop() float64 {
	if m != nil {
		return m.TestStop
	}
	return 0
}

func (m *CreateJobRequest) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

func (m *CreateJobRequest) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *CreateJobRequest) GetRegressionId() string {
	if m != nil {
		return m.RegressionId
	}
	return ""
}

func (m *CreateJobRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateJobRequest) GetTank() string {
	if m != nil {
		return m.Tank
	}
	return ""
}

func (m *CreateJobRequest) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *CreateJobRequest) GetEnvironmentDetails() string {
	if m != nil {
		return m.EnvironmentDetails
	}
	return ""
}

func (m *CreateJobRequest) GetCollections() []*Collection {
	if m != nil {
		return m.Collections
	}
	return nil
}

type CreateJobResponse struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateJobResponse) Reset()         { *m = CreateJobResponse{} }
func (m *CreateJobResponse) String() string { return proto.CompactTextString(m) }
func (*CreateJobResponse) ProtoMessage()    {}
func (*CreateJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{3}
}
func (m *CreateJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJobResponse.Merge(dst, src)
}
func (m *CreateJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJobResponse proto.InternalMessageInfo

func (m *CreateJobResponse) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type JobRequest struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobRequest) Reset()         { *m = JobRequest{} }
func (m *JobRequest) String() string { return proto.CompactTextString(m) }
func (*JobRequest) ProtoMessage()    {}
func (*JobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{4}
}
func (m *JobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *JobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobRequest.Merge(dst, src)
}
func (m *JobRequest) XXX_Size() int {
	return m.Size()
}
func (m *JobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_JobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_JobRequest proto.InternalMessageInfo

func (m *JobRequest) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type JobResponse struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobResponse) Reset()         { *m = JobResponse{} }
func (m *JobResponse) String() string { return proto.CompactTextString(m) }
func (*JobResponse) ProtoMessage()    {}
func (*JobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{5}
}
func (m *JobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *JobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobResponse.Merge(dst, src)
}
func (m *JobResponse) XXX_Size() int {
	return m.Size()
}
func (m *JobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_JobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_JobResponse proto.InternalMessageInfo

func (m *JobResponse) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type LastJobsRequest struct {
	Page                 []string `protobuf:"bytes,1,rep,name=page,proto3" json:"page,omitempty"`
	Limit                []string `protobuf:"bytes,2,rep,name=limit,proto3" json:"limit,omitempty"`
	Author               []string `protobuf:"bytes,3,rep,name=author,proto3" json:"author,omitempty"`
	Status               []string `protobuf:"bytes,4,rep,name=status,proto3" json:"status,omitempty"`
	Target               []string `protobuf:"bytes,5,rep,name=target,proto3" json:"target,omitempty"`
	Description          []string `protobuf:"bytes,6,rep,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LastJobsRequest) Reset()         { *m = LastJobsRequest{} }
func (m *LastJobsRequest) String() string { return proto.CompactTextString(m) }
func (*LastJobsRequest) ProtoMessage()    {}
func (*LastJobsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{6}
}
func (m *LastJobsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastJobsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastJobsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LastJobsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastJobsRequest.Merge(dst, src)
}
func (m *LastJobsRequest) XXX_Size() int {
	return m.Size()
}
func (m *LastJobsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LastJobsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LastJobsRequest proto.InternalMessageInfo

func (m *LastJobsRequest) GetPage() []string {
	if m != nil {
		return m.Page
	}
	return nil
}

func (m *LastJobsRequest) GetLimit() []string {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *LastJobsRequest) GetAuthor() []string {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *LastJobsRequest) GetStatus() []string {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *LastJobsRequest) GetTarget() []string {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *LastJobsRequest) GetDescription() []string {
	if m != nil {
		return m.Description
	}
	return nil
}

type LastJobsResponse struct {
	Jobs                 []*Job   `protobuf:"bytes,1,rep,name=jobs,proto3" json:"jobs,omitempty"`
	Count                int32    `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LastJobsResponse) Reset()         { *m = LastJobsResponse{} }
func (m *LastJobsResponse) String() string { return proto.CompactTextString(m) }
func (*LastJobsResponse) ProtoMessage()    {}
func (*LastJobsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{7}
}
func (m *LastJobsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastJobsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastJobsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LastJobsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastJobsResponse.Merge(dst, src)
}
func (m *LastJobsResponse) XXX_Size() int {
	return m.Size()
}
func (m *LastJobsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LastJobsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LastJobsResponse proto.InternalMessageInfo

func (m *LastJobsResponse) GetJobs() []*Job {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *LastJobsResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type GetJobParamsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetJobParamsRequest) Reset()         { *m = GetJobParamsRequest{} }
func (m *GetJobParamsRequest) String() string { return proto.CompactTextString(m) }
func (*GetJobParamsRequest) ProtoMessage()    {}
func (*GetJobParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{8}
}
func (m *GetJobParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetJobParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetJobParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetJobParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetJobParamsRequest.Merge(dst, src)
}
func (m *GetJobParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetJobParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetJobParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetJobParamsRequest proto.InternalMessageInfo

type GetJobParamsResponse struct {
	Authors              []string `protobuf:"bytes,1,rep,name=authors,proto3" json:"authors,omitempty"`
	Statuses             []string `protobuf:"bytes,2,rep,name=statuses,proto3" json:"statuses,omitempty"`
	Targets              []string `protobuf:"bytes,3,rep,name=targets,proto3" json:"targets,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetJobParamsResponse) Reset()         { *m = GetJobParamsResponse{} }
func (m *GetJobParamsResponse) String() string { return proto.CompactTextString(m) }
func (*GetJobParamsResponse) ProtoMessage()    {}
func (*GetJobParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{9}
}
func (m *GetJobParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetJobParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetJobParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetJobParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetJobParamsResponse.Merge(dst, src)
}
func (m *GetJobParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetJobParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetJobParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetJobParamsResponse proto.InternalMessageInfo

func (m *GetJobParamsResponse) GetAuthors() []string {
	if m != nil {
		return m.Authors
	}
	return nil
}

func (m *GetJobParamsResponse) GetStatuses() []string {
	if m != nil {
		return m.Statuses
	}
	return nil
}

func (m *GetJobParamsResponse) GetTargets() []string {
	if m != nil {
		return m.Targets
	}
	return nil
}

type UpdateJobRequest struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TestStart            float64  `protobuf:"fixed64,2,opt,name=test_start,json=testStart,proto3" json:"test_start,omitempty"`
	TestStop             float64  `protobuf:"fixed64,3,opt,name=test_stop,json=testStop,proto3" json:"test_stop,omitempty"`
	Config               string   `protobuf:"bytes,4,opt,name=config,proto3" json:"config,omitempty"`
	Author               string   `protobuf:"bytes,5,opt,name=author,proto3" json:"author,omitempty"`
	RegressionId         string   `protobuf:"bytes,6,opt,name=regression_id,json=regressionId,proto3" json:"regression_id,omitempty"`
	Description          string   `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	Tank                 string   `protobuf:"bytes,8,opt,name=tank,proto3" json:"tank,omitempty"`
	Target               string   `protobuf:"bytes,9,opt,name=target,proto3" json:"target,omitempty"`
	EnvironmentDetails   string   `protobuf:"bytes,10,opt,name=environment_details,json=environmentDetails,proto3" json:"environment_details,omitempty"`
	Status               string   `protobuf:"bytes,11,opt,name=status,proto3" json:"status,omitempty"`
	AutostopTime         float64  `protobuf:"fixed64,12,opt,name=autostop_time,json=autostopTime,proto3" json:"autostop_time,omitempty"`
	AutostopMessage      string   `protobuf:"bytes,13,opt,name=autostop_message,json=autostopMessage,proto3" json:"autostop_message,omitempty"`
	Imbalance            int32    `protobuf:"varint,14,opt,name=imbalance,proto3" json:"imbalance,omitempty"`
	Collections          []int32  `protobuf:"varint,15,rep,packed,name=collections,proto3" json:"collections,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateJobRequest) Reset()         { *m = UpdateJobRequest{} }
func (m *UpdateJobRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateJobRequest) ProtoMessage()    {}
func (*UpdateJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{10}
}
func (m *UpdateJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateJobRequest.Merge(dst, src)
}
func (m *UpdateJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateJobRequest proto.InternalMessageInfo

func (m *UpdateJobRequest) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateJobRequest) GetTestStart() float64 {
	if m != nil {
		return m.TestStart
	}
	return 0
}

func (m *UpdateJobRequest) GetTestStop() float64 {
	if m != nil {
		return m.TestStop
	}
	return 0
}

func (m *UpdateJobRequest) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

func (m *UpdateJobRequest) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *UpdateJobRequest) GetRegressionId() string {
	if m != nil {
		return m.RegressionId
	}
	return ""
}

func (m *UpdateJobRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *UpdateJobRequest) GetTank() string {
	if m != nil {
		return m.Tank
	}
	return ""
}

func (m *UpdateJobRequest) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *UpdateJobRequest) GetEnvironmentDetails() string {
	if m != nil {
		return m.EnvironmentDetails
	}
	return ""
}

func (m *UpdateJobRequest) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *UpdateJobRequest) GetAutostopTime() float64 {
	if m != nil {
		return m.AutostopTime
	}
	return 0
}

func (m *UpdateJobRequest) GetAutostopMessage() string {
	if m != nil {
		return m.AutostopMessage
	}
	return ""
}

func (m *UpdateJobRequest) GetImbalance() int32 {
	if m != nil {
		return m.Imbalance
	}
	return 0
}

func (m *UpdateJobRequest) GetCollections() []int32 {
	if m != nil {
		return m.Collections
	}
	return nil
}

type UpdateJobResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateJobResponse) Reset()         { *m = UpdateJobResponse{} }
func (m *UpdateJobResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateJobResponse) ProtoMessage()    {}
func (*UpdateJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{11}
}
func (m *UpdateJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateJobResponse.Merge(dst, src)
}
func (m *UpdateJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateJobResponse proto.InternalMessageInfo

type DeleteJobRequest struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteJobRequest) Reset()         { *m = DeleteJobRequest{} }
func (m *DeleteJobRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteJobRequest) ProtoMessage()    {}
func (*DeleteJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{12}
}
func (m *DeleteJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeleteJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteJobRequest.Merge(dst, src)
}
func (m *DeleteJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteJobRequest proto.InternalMessageInfo

func (m *DeleteJobRequest) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type DeleteJobResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteJobResponse) Reset()         { *m = DeleteJobResponse{} }
func (m *DeleteJobResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteJobResponse) ProtoMessage()    {}
func (*DeleteJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{13}
}
func (m *DeleteJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeleteJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteJobResponse.Merge(dst, src)
}
func (m *DeleteJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteJobResponse proto.InternalMessageInfo

type JobAggregate struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Label                string   `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
	Q50                  float32  `protobuf:"fixed32,3,opt,name=q50,proto3" json:"q50,omitempty"`
	Q75                  float32  `protobuf:"fixed32,4,opt,name=q75,proto3" json:"q75,omitempty"`
	Q80                  float32  `protobuf:"fixed32,5,opt,name=q80,proto3" json:"q80,omitempty"`
	Q85                  float32  `protobuf:"fixed32,6,opt,name=q85,proto3" json:"q85,omitempty"`
	Q90                  float32  `protobuf:"fixed32,7,opt,name=q90,proto3" json:"q90,omitempty"`
	Q95                  float32  `protobuf:"fixed32,8,opt,name=q95,proto3" json:"q95,omitempty"`
	Q98                  float32  `protobuf:"fixed32,9,opt,name=q98,proto3" json:"q98,omitempty"`
	Q99                  float32  `protobuf:"fixed32,10,opt,name=q99,proto3" json:"q99,omitempty"`
	Q100                 float32  `protobuf:"fixed32,11,opt,name=q100,proto3" json:"q100,omitempty"`
	Avg                  float32  `protobuf:"fixed32,12,opt,name=avg,proto3" json:"avg,omitempty"`
	ResponseCode         string   `protobuf:"bytes,13,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	OkCount              int64    `protobuf:"varint,14,opt,name=ok_count,json=okCount,proto3" json:"ok_count,omitempty"`
	ErrCount             int64    `protobuf:"varint,15,opt,name=err_count,json=errCount,proto3" json:"err_count,omitempty"`
	NetRecv              float32  `protobuf:"fixed32,16,opt,name=net_recv,json=netRecv,proto3" json:"net_recv,omitempty"`
	NetSend              float32  `protobuf:"fixed32,17,opt,name=net_send,json=netSend,proto3" json:"net_send,omitempty"`
	JobId                int32    `protobuf:"varint,18,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobAggregate) Reset()         { *m = JobAggregate{} }
func (m *JobAggregate) String() string { return proto.CompactTextString(m) }
func (*JobAggregate) ProtoMessage()    {}
func (*JobAggregate) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{14}
}
func (m *JobAggregate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobAggregate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobAggregate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *JobAggregate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobAggregate.Merge(dst, src)
}
func (m *JobAggregate) XXX_Size() int {
	return m.Size()
}
func (m *JobAggregate) XXX_DiscardUnknown() {
	xxx_messageInfo_JobAggregate.DiscardUnknown(m)
}

var xxx_messageInfo_JobAggregate proto.InternalMessageInfo

func (m *JobAggregate) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *JobAggregate) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *JobAggregate) GetQ50() float32 {
	if m != nil {
		return m.Q50
	}
	return 0
}

func (m *JobAggregate) GetQ75() float32 {
	if m != nil {
		return m.Q75
	}
	return 0
}

func (m *JobAggregate) GetQ80() float32 {
	if m != nil {
		return m.Q80
	}
	return 0
}

func (m *JobAggregate) GetQ85() float32 {
	if m != nil {
		return m.Q85
	}
	return 0
}

func (m *JobAggregate) GetQ90() float32 {
	if m != nil {
		return m.Q90
	}
	return 0
}

func (m *JobAggregate) GetQ95() float32 {
	if m != nil {
		return m.Q95
	}
	return 0
}

func (m *JobAggregate) GetQ98() float32 {
	if m != nil {
		return m.Q98
	}
	return 0
}

func (m *JobAggregate) GetQ99() float32 {
	if m != nil {
		return m.Q99
	}
	return 0
}

func (m *JobAggregate) GetQ100() float32 {
	if m != nil {
		return m.Q100
	}
	return 0
}

func (m *JobAggregate) GetAvg() float32 {
	if m != nil {
		return m.Avg
	}
	return 0
}

func (m *JobAggregate) GetResponseCode() string {
	if m != nil {
		return m.ResponseCode
	}
	return ""
}

func (m *JobAggregate) GetOkCount() int64 {
	if m != nil {
		return m.OkCount
	}
	return 0
}

func (m *JobAggregate) GetErrCount() int64 {
	if m != nil {
		return m.ErrCount
	}
	return 0
}

func (m *JobAggregate) GetNetRecv() float32 {
	if m != nil {
		return m.NetRecv
	}
	return 0
}

func (m *JobAggregate) GetNetSend() float32 {
	if m != nil {
		return m.NetSend
	}
	return 0
}

func (m *JobAggregate) GetJobId() int32 {
	if m != nil {
		return m.JobId
	}
	return 0
}

type CreateAggregatesRequest struct {
	Label                string   `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Q50                  float32  `protobuf:"fixed32,2,opt,name=q50,proto3" json:"q50,omitempty"`
	Q75                  float32  `protobuf:"fixed32,3,opt,name=q75,proto3" json:"q75,omitempty"`
	Q80                  float32  `protobuf:"fixed32,4,opt,name=q80,proto3" json:"q80,omitempty"`
	Q85                  float32  `protobuf:"fixed32,5,opt,name=q85,proto3" json:"q85,omitempty"`
	Q90                  float32  `protobuf:"fixed32,6,opt,name=q90,proto3" json:"q90,omitempty"`
	Q95                  float32  `protobuf:"fixed32,7,opt,name=q95,proto3" json:"q95,omitempty"`
	Q98                  float32  `protobuf:"fixed32,8,opt,name=q98,proto3" json:"q98,omitempty"`
	Q99                  float32  `protobuf:"fixed32,9,opt,name=q99,proto3" json:"q99,omitempty"`
	Q100                 float32  `protobuf:"fixed32,10,opt,name=q100,proto3" json:"q100,omitempty"`
	Avg                  float32  `protobuf:"fixed32,11,opt,name=avg,proto3" json:"avg,omitempty"`
	ResponseCode         string   `protobuf:"bytes,12,opt,name=response_code,json=responseCode,proto3" json:"response_code,omitempty"`
	OkCount              int64    `protobuf:"varint,13,opt,name=ok_count,json=okCount,proto3" json:"ok_count,omitempty"`
	ErrCount             int64    `protobuf:"varint,14,opt,name=err_count,json=errCount,proto3" json:"err_count,omitempty"`
	NetRecv              float32  `protobuf:"fixed32,15,opt,name=net_recv,json=netRecv,proto3" json:"net_recv,omitempty"`
	NetSend              float32  `protobuf:"fixed32,16,opt,name=net_send,json=netSend,proto3" json:"net_send,omitempty"`
	JobId                int32    `protobuf:"varint,17,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateAggregatesRequest) Reset()         { *m = CreateAggregatesRequest{} }
func (m *CreateAggregatesRequest) String() string { return proto.CompactTextString(m) }
func (*CreateAggregatesRequest) ProtoMessage()    {}
func (*CreateAggregatesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{15}
}
func (m *CreateAggregatesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAggregatesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAggregatesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateAggregatesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAggregatesRequest.Merge(dst, src)
}
func (m *CreateAggregatesRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateAggregatesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAggregatesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAggregatesRequest proto.InternalMessageInfo

func (m *CreateAggregatesRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *CreateAggregatesRequest) GetQ50() float32 {
	if m != nil {
		return m.Q50
	}
	return 0
}

func (m *CreateAggregatesRequest) GetQ75() float32 {
	if m != nil {
		return m.Q75
	}
	return 0
}

func (m *CreateAggregatesRequest) GetQ80() float32 {
	if m != nil {
		return m.Q80
	}
	return 0
}

func (m *CreateAggregatesRequest) GetQ85() float32 {
	if m != nil {
		return m.Q85
	}
	return 0
}

func (m *CreateAggregatesRequest) GetQ90() float32 {
	if m != nil {
		return m.Q90
	}
	return 0
}

func (m *CreateAggregatesRequest) GetQ95() float32 {
	if m != nil {
		return m.Q95
	}
	return 0
}

func (m *CreateAggregatesRequest) GetQ98() float32 {
	if m != nil {
		return m.Q98
	}
	return 0
}

func (m *CreateAggregatesRequest) GetQ99() float32 {
	if m != nil {
		return m.Q99
	}
	return 0
}

func (m *CreateAggregatesRequest) GetQ100() float32 {
	if m != nil {
		return m.Q100
	}
	return 0
}

func (m *CreateAggregatesRequest) GetAvg() float32 {
	if m != nil {
		return m.Avg
	}
	return 0
}

func (m *CreateAggregatesRequest) GetResponseCode() string {
	if m != nil {
		return m.ResponseCode
	}
	return ""
}

func (m *CreateAggregatesRequest) GetOkCount() int64 {
	if m != nil {
		return m.OkCount
	}
	return 0
}

func (m *CreateAggregatesRequest) GetErrCount() int64 {
	if m != nil {
		return m.ErrCount
	}
	return 0
}

func (m *CreateAggregatesRequest) GetNetRecv() float32 {
	if m != nil {
		return m.NetRecv
	}
	return 0
}

func (m *CreateAggregatesRequest) GetNetSend() float32 {
	if m != nil {
		return m.NetSend
	}
	return 0
}

func (m *CreateAggregatesRequest) GetJobId() int32 {
	if m != nil {
		return m.JobId
	}
	return 0
}

type CreateAggregatesResponse struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateAggregatesResponse) Reset()         { *m = CreateAggregatesResponse{} }
func (m *CreateAggregatesResponse) String() string { return proto.CompactTextString(m) }
func (*CreateAggregatesResponse) ProtoMessage()    {}
func (*CreateAggregatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{16}
}
func (m *CreateAggregatesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateAggregatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateAggregatesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateAggregatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateAggregatesResponse.Merge(dst, src)
}
func (m *CreateAggregatesResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateAggregatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateAggregatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateAggregatesResponse proto.InternalMessageInfo

func (m *CreateAggregatesResponse) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type GetAggregatesRequest struct {
	TestId               int32    `protobuf:"varint,1,opt,name=test_id,json=testId,proto3" json:"test_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAggregatesRequest) Reset()         { *m = GetAggregatesRequest{} }
func (m *GetAggregatesRequest) String() string { return proto.CompactTextString(m) }
func (*GetAggregatesRequest) ProtoMessage()    {}
func (*GetAggregatesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{17}
}
func (m *GetAggregatesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAggregatesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAggregatesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAggregatesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAggregatesRequest.Merge(dst, src)
}
func (m *GetAggregatesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetAggregatesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAggregatesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetAggregatesRequest proto.InternalMessageInfo

func (m *GetAggregatesRequest) GetTestId() int32 {
	if m != nil {
		return m.TestId
	}
	return 0
}

type GetAggregatesResponse struct {
	Aggregates           []*JobAggregate `protobuf:"bytes,1,rep,name=aggregates,proto3" json:"aggregates,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetAggregatesResponse) Reset()         { *m = GetAggregatesResponse{} }
func (m *GetAggregatesResponse) String() string { return proto.CompactTextString(m) }
func (*GetAggregatesResponse) ProtoMessage()    {}
func (*GetAggregatesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{18}
}
func (m *GetAggregatesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAggregatesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAggregatesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetAggregatesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAggregatesResponse.Merge(dst, src)
}
func (m *GetAggregatesResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetAggregatesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAggregatesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetAggregatesResponse proto.InternalMessageInfo

func (m *GetAggregatesResponse) GetAggregates() []*JobAggregate {
	if m != nil {
		return m.Aggregates
	}
	return nil
}

type GetCollectionsRequest struct {
	Page                 []string `protobuf:"bytes,1,rep,name=page,proto3" json:"page,omitempty"`
	Limit                []string `protobuf:"bytes,2,rep,name=limit,proto3" json:"limit,omitempty"`
	CollectionId         []int32  `protobuf:"varint,3,rep,packed,name=collection_id,json=collectionId,proto3" json:"collection_id,omitempty"`
	Env                  []string `protobuf:"bytes,4,rep,name=env,proto3" json:"env,omitempty"`
	Project              []string `protobuf:"bytes,5,rep,name=project,proto3" json:"project,omitempty"`
	Ref                  []string `protobuf:"bytes,6,rep,name=ref,proto3" json:"ref,omitempty"`
	Name                 []string `protobuf:"bytes,7,rep,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetCollectionsRequest) Reset()         { *m = GetCollectionsRequest{} }
func (m *GetCollectionsRequest) String() string { return proto.CompactTextString(m) }
func (*GetCollectionsRequest) ProtoMessage()    {}
func (*GetCollectionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{19}
}
func (m *GetCollectionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCollectionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCollectionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetCollectionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCollectionsRequest.Merge(dst, src)
}
func (m *GetCollectionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCollectionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCollectionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCollectionsRequest proto.InternalMessageInfo

func (m *GetCollectionsRequest) GetPage() []string {
	if m != nil {
		return m.Page
	}
	return nil
}

func (m *GetCollectionsRequest) GetLimit() []string {
	if m != nil {
		return m.Limit
	}
	return nil
}

func (m *GetCollectionsRequest) GetCollectionId() []int32 {
	if m != nil {
		return m.CollectionId
	}
	return nil
}

func (m *GetCollectionsRequest) GetEnv() []string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *GetCollectionsRequest) GetProject() []string {
	if m != nil {
		return m.Project
	}
	return nil
}

func (m *GetCollectionsRequest) GetRef() []string {
	if m != nil {
		return m.Ref
	}
	return nil
}

func (m *GetCollectionsRequest) GetName() []string {
	if m != nil {
		return m.Name
	}
	return nil
}

type GetCollectionsResponse struct {
	Collections          []*Collection `protobuf:"bytes,1,rep,name=collections,proto3" json:"collections,omitempty"`
	Count                int32         `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *GetCollectionsResponse) Reset()         { *m = GetCollectionsResponse{} }
func (m *GetCollectionsResponse) String() string { return proto.CompactTextString(m) }
func (*GetCollectionsResponse) ProtoMessage()    {}
func (*GetCollectionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{20}
}
func (m *GetCollectionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCollectionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCollectionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetCollectionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCollectionsResponse.Merge(dst, src)
}
func (m *GetCollectionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetCollectionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCollectionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCollectionsResponse proto.InternalMessageInfo

func (m *GetCollectionsResponse) GetCollections() []*Collection {
	if m != nil {
		return m.Collections
	}
	return nil
}

func (m *GetCollectionsResponse) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type GetCollectionParamsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetCollectionParamsRequest) Reset()         { *m = GetCollectionParamsRequest{} }
func (m *GetCollectionParamsRequest) String() string { return proto.CompactTextString(m) }
func (*GetCollectionParamsRequest) ProtoMessage()    {}
func (*GetCollectionParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{21}
}
func (m *GetCollectionParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCollectionParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCollectionParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetCollectionParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCollectionParamsRequest.Merge(dst, src)
}
func (m *GetCollectionParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCollectionParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCollectionParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCollectionParamsRequest proto.InternalMessageInfo

type GetCollectionParamsResponse struct {
	Envs                 []string   `protobuf:"bytes,1,rep,name=envs,proto3" json:"envs,omitempty"`
	Projects             []*Project `protobuf:"bytes,2,rep,name=projects,proto3" json:"projects,omitempty"`
	Refs                 []string   `protobuf:"bytes,3,rep,name=refs,proto3" json:"refs,omitempty"`
	Names                []string   `protobuf:"bytes,4,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetCollectionParamsResponse) Reset()         { *m = GetCollectionParamsResponse{} }
func (m *GetCollectionParamsResponse) String() string { return proto.CompactTextString(m) }
func (*GetCollectionParamsResponse) ProtoMessage()    {}
func (*GetCollectionParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{22}
}
func (m *GetCollectionParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCollectionParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCollectionParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetCollectionParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCollectionParamsResponse.Merge(dst, src)
}
func (m *GetCollectionParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetCollectionParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCollectionParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCollectionParamsResponse proto.InternalMessageInfo

func (m *GetCollectionParamsResponse) GetEnvs() []string {
	if m != nil {
		return m.Envs
	}
	return nil
}

func (m *GetCollectionParamsResponse) GetProjects() []*Project {
	if m != nil {
		return m.Projects
	}
	return nil
}

func (m *GetCollectionParamsResponse) GetRefs() []string {
	if m != nil {
		return m.Refs
	}
	return nil
}

func (m *GetCollectionParamsResponse) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type Project struct {
	Project              string   `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	Service              string   `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Project) Reset()         { *m = Project{} }
func (m *Project) String() string { return proto.CompactTextString(m) }
func (*Project) ProtoMessage()    {}
func (*Project) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{23}
}
func (m *Project) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Project) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Project.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Project) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Project.Merge(dst, src)
}
func (m *Project) XXX_Size() int {
	return m.Size()
}
func (m *Project) XXX_DiscardUnknown() {
	xxx_messageInfo_Project.DiscardUnknown(m)
}

var xxx_messageInfo_Project proto.InternalMessageInfo

func (m *Project) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *Project) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

type Ammo struct {
	Etag                 string   `protobuf:"bytes,1,opt,name=etag,proto3" json:"etag,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	LastModified         string   `protobuf:"bytes,3,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	LastUsed             float64  `protobuf:"fixed64,4,opt,name=last_used,json=lastUsed,proto3" json:"last_used,omitempty"`
	Author               string   `protobuf:"bytes,5,opt,name=author,proto3" json:"author,omitempty"`
	Size_                int64    `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	Path                 string   `protobuf:"bytes,7,opt,name=path,proto3" json:"path,omitempty"`
	Type                 string   `protobuf:"bytes,8,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ammo) Reset()         { *m = Ammo{} }
func (m *Ammo) String() string { return proto.CompactTextString(m) }
func (*Ammo) ProtoMessage()    {}
func (*Ammo) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{24}
}
func (m *Ammo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ammo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ammo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Ammo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ammo.Merge(dst, src)
}
func (m *Ammo) XXX_Size() int {
	return m.Size()
}
func (m *Ammo) XXX_DiscardUnknown() {
	xxx_messageInfo_Ammo.DiscardUnknown(m)
}

var xxx_messageInfo_Ammo proto.InternalMessageInfo

func (m *Ammo) GetEtag() string {
	if m != nil {
		return m.Etag
	}
	return ""
}

func (m *Ammo) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Ammo) GetLastModified() string {
	if m != nil {
		return m.LastModified
	}
	return ""
}

func (m *Ammo) GetLastUsed() float64 {
	if m != nil {
		return m.LastUsed
	}
	return 0
}

func (m *Ammo) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Ammo) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Ammo) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Ammo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type UploadAmmoRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	File                 string   `protobuf:"bytes,2,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadAmmoRequest) Reset()         { *m = UploadAmmoRequest{} }
func (m *UploadAmmoRequest) String() string { return proto.CompactTextString(m) }
func (*UploadAmmoRequest) ProtoMessage()    {}
func (*UploadAmmoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{25}
}
func (m *UploadAmmoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadAmmoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadAmmoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UploadAmmoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadAmmoRequest.Merge(dst, src)
}
func (m *UploadAmmoRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadAmmoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadAmmoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadAmmoRequest proto.InternalMessageInfo

func (m *UploadAmmoRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UploadAmmoRequest) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

type UploadAmmoResponse struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadAmmoResponse) Reset()         { *m = UploadAmmoResponse{} }
func (m *UploadAmmoResponse) String() string { return proto.CompactTextString(m) }
func (*UploadAmmoResponse) ProtoMessage()    {}
func (*UploadAmmoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{26}
}
func (m *UploadAmmoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadAmmoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadAmmoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UploadAmmoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadAmmoResponse.Merge(dst, src)
}
func (m *UploadAmmoResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadAmmoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadAmmoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadAmmoResponse proto.InternalMessageInfo

func (m *UploadAmmoResponse) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type ListAmmoRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAmmoRequest) Reset()         { *m = ListAmmoRequest{} }
func (m *ListAmmoRequest) String() string { return proto.CompactTextString(m) }
func (*ListAmmoRequest) ProtoMessage()    {}
func (*ListAmmoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{27}
}
func (m *ListAmmoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAmmoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAmmoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListAmmoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAmmoRequest.Merge(dst, src)
}
func (m *ListAmmoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAmmoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAmmoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAmmoRequest proto.InternalMessageInfo

type ListAmmoResponse struct {
	Ammo                 []*Ammo  `protobuf:"bytes,1,rep,name=ammo,proto3" json:"ammo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListAmmoResponse) Reset()         { *m = ListAmmoResponse{} }
func (m *ListAmmoResponse) String() string { return proto.CompactTextString(m) }
func (*ListAmmoResponse) ProtoMessage()    {}
func (*ListAmmoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{28}
}
func (m *ListAmmoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAmmoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAmmoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListAmmoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAmmoResponse.Merge(dst, src)
}
func (m *ListAmmoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAmmoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAmmoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAmmoResponse proto.InternalMessageInfo

func (m *ListAmmoResponse) GetAmmo() []*Ammo {
	if m != nil {
		return m.Ammo
	}
	return nil
}

type DeleteAmmoRequest struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteAmmoRequest) Reset()         { *m = DeleteAmmoRequest{} }
func (m *DeleteAmmoRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteAmmoRequest) ProtoMessage()    {}
func (*DeleteAmmoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{29}
}
func (m *DeleteAmmoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteAmmoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteAmmoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeleteAmmoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteAmmoRequest.Merge(dst, src)
}
func (m *DeleteAmmoRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteAmmoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteAmmoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteAmmoRequest proto.InternalMessageInfo

func (m *DeleteAmmoRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type DeleteAmmoResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteAmmoResponse) Reset()         { *m = DeleteAmmoResponse{} }
func (m *DeleteAmmoResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteAmmoResponse) ProtoMessage()    {}
func (*DeleteAmmoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{30}
}
func (m *DeleteAmmoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteAmmoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteAmmoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeleteAmmoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteAmmoResponse.Merge(dst, src)
}
func (m *DeleteAmmoResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteAmmoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteAmmoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteAmmoResponse proto.InternalMessageInfo

type Artifact struct {
	Etag                 string   `protobuf:"bytes,1,opt,name=etag,proto3" json:"etag,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	LastModified         string   `protobuf:"bytes,3,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
	Size_                int64    `protobuf:"varint,6,opt,name=size,proto3" json:"size,omitempty"`
	Path                 string   `protobuf:"bytes,7,opt,name=path,proto3" json:"path,omitempty"`
	Job                  int32    `protobuf:"varint,9,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Artifact) Reset()         { *m = Artifact{} }
func (m *Artifact) String() string { return proto.CompactTextString(m) }
func (*Artifact) ProtoMessage()    {}
func (*Artifact) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{31}
}
func (m *Artifact) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Artifact) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Artifact.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Artifact) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Artifact.Merge(dst, src)
}
func (m *Artifact) XXX_Size() int {
	return m.Size()
}
func (m *Artifact) XXX_DiscardUnknown() {
	xxx_messageInfo_Artifact.DiscardUnknown(m)
}

var xxx_messageInfo_Artifact proto.InternalMessageInfo

func (m *Artifact) GetEtag() string {
	if m != nil {
		return m.Etag
	}
	return ""
}

func (m *Artifact) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Artifact) GetLastModified() string {
	if m != nil {
		return m.LastModified
	}
	return ""
}

func (m *Artifact) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Artifact) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Artifact) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

type UploadArtifactRequest struct {
	Job                  string   `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	File                 string   `protobuf:"bytes,3,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadArtifactRequest) Reset()         { *m = UploadArtifactRequest{} }
func (m *UploadArtifactRequest) String() string { return proto.CompactTextString(m) }
func (*UploadArtifactRequest) ProtoMessage()    {}
func (*UploadArtifactRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{32}
}
func (m *UploadArtifactRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadArtifactRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadArtifactRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UploadArtifactRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadArtifactRequest.Merge(dst, src)
}
func (m *UploadArtifactRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadArtifactRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadArtifactRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadArtifactRequest proto.InternalMessageInfo

func (m *UploadArtifactRequest) GetJob() string {
	if m != nil {
		return m.Job
	}
	return ""
}

func (m *UploadArtifactRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UploadArtifactRequest) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

type UploadArtifactResponse struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadArtifactResponse) Reset()         { *m = UploadArtifactResponse{} }
func (m *UploadArtifactResponse) String() string { return proto.CompactTextString(m) }
func (*UploadArtifactResponse) ProtoMessage()    {}
func (*UploadArtifactResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{33}
}
func (m *UploadArtifactResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadArtifactResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadArtifactResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UploadArtifactResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadArtifactResponse.Merge(dst, src)
}
func (m *UploadArtifactResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadArtifactResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadArtifactResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadArtifactResponse proto.InternalMessageInfo

func (m *UploadArtifactResponse) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type ListArtifactsRequest struct {
	Job                  int32    `protobuf:"varint,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListArtifactsRequest) Reset()         { *m = ListArtifactsRequest{} }
func (m *ListArtifactsRequest) String() string { return proto.CompactTextString(m) }
func (*ListArtifactsRequest) ProtoMessage()    {}
func (*ListArtifactsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{34}
}
func (m *ListArtifactsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListArtifactsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListArtifactsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListArtifactsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListArtifactsRequest.Merge(dst, src)
}
func (m *ListArtifactsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListArtifactsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListArtifactsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListArtifactsRequest proto.InternalMessageInfo

func (m *ListArtifactsRequest) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

type ListArtifactsResponse struct {
	Artifacts            []*Artifact `protobuf:"bytes,1,rep,name=artifacts,proto3" json:"artifacts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ListArtifactsResponse) Reset()         { *m = ListArtifactsResponse{} }
func (m *ListArtifactsResponse) String() string { return proto.CompactTextString(m) }
func (*ListArtifactsResponse) ProtoMessage()    {}
func (*ListArtifactsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{35}
}
func (m *ListArtifactsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListArtifactsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListArtifactsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListArtifactsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListArtifactsResponse.Merge(dst, src)
}
func (m *ListArtifactsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListArtifactsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListArtifactsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListArtifactsResponse proto.InternalMessageInfo

func (m *ListArtifactsResponse) GetArtifacts() []*Artifact {
	if m != nil {
		return m.Artifacts
	}
	return nil
}

type Joint struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Jobs                 []*Job   `protobuf:"bytes,2,rep,name=jobs,proto3" json:"jobs,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Joint) Reset()         { *m = Joint{} }
func (m *Joint) String() string { return proto.CompactTextString(m) }
func (*Joint) ProtoMessage()    {}
func (*Joint) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{36}
}
func (m *Joint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Joint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Joint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Joint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Joint.Merge(dst, src)
}
func (m *Joint) XXX_Size() int {
	return m.Size()
}
func (m *Joint) XXX_DiscardUnknown() {
	xxx_messageInfo_Joint.DiscardUnknown(m)
}

var xxx_messageInfo_Joint proto.InternalMessageInfo

func (m *Joint) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Joint) GetJobs() []*Job {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *Joint) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ListJointsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListJointsRequest) Reset()         { *m = ListJointsRequest{} }
func (m *ListJointsRequest) String() string { return proto.CompactTextString(m) }
func (*ListJointsRequest) ProtoMessage()    {}
func (*ListJointsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{37}
}
func (m *ListJointsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListJointsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListJointsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListJointsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListJointsRequest.Merge(dst, src)
}
func (m *ListJointsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListJointsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListJointsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListJointsRequest proto.InternalMessageInfo

type ListJointsResponse struct {
	Joints               []*Joint `protobuf:"bytes,1,rep,name=joints,proto3" json:"joints,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListJointsResponse) Reset()         { *m = ListJointsResponse{} }
func (m *ListJointsResponse) String() string { return proto.CompactTextString(m) }
func (*ListJointsResponse) ProtoMessage()    {}
func (*ListJointsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{38}
}
func (m *ListJointsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListJointsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListJointsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ListJointsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListJointsResponse.Merge(dst, src)
}
func (m *ListJointsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListJointsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListJointsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListJointsResponse proto.InternalMessageInfo

func (m *ListJointsResponse) GetJoints() []*Joint {
	if m != nil {
		return m.Joints
	}
	return nil
}

type GetJointRequest struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetJointRequest) Reset()         { *m = GetJointRequest{} }
func (m *GetJointRequest) String() string { return proto.CompactTextString(m) }
func (*GetJointRequest) ProtoMessage()    {}
func (*GetJointRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{39}
}
func (m *GetJointRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetJointRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetJointRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetJointRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetJointRequest.Merge(dst, src)
}
func (m *GetJointRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetJointRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetJointRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetJointRequest proto.InternalMessageInfo

func (m *GetJointRequest) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type GetJointResponse struct {
	Joint                *Joint   `protobuf:"bytes,1,opt,name=joint,proto3" json:"joint,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetJointResponse) Reset()         { *m = GetJointResponse{} }
func (m *GetJointResponse) String() string { return proto.CompactTextString(m) }
func (*GetJointResponse) ProtoMessage()    {}
func (*GetJointResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{40}
}
func (m *GetJointResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetJointResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetJointResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GetJointResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetJointResponse.Merge(dst, src)
}
func (m *GetJointResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetJointResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetJointResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetJointResponse proto.InternalMessageInfo

func (m *GetJointResponse) GetJoint() *Joint {
	if m != nil {
		return m.Joint
	}
	return nil
}

type CreateJointRequest struct {
	Jobs                 []int32  `protobuf:"varint,1,rep,packed,name=jobs,proto3" json:"jobs,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateJointRequest) Reset()         { *m = CreateJointRequest{} }
func (m *CreateJointRequest) String() string { return proto.CompactTextString(m) }
func (*CreateJointRequest) ProtoMessage()    {}
func (*CreateJointRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{41}
}
func (m *CreateJointRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJointRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJointRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateJointRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJointRequest.Merge(dst, src)
}
func (m *CreateJointRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateJointRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJointRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJointRequest proto.InternalMessageInfo

func (m *CreateJointRequest) GetJobs() []int32 {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *CreateJointRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type CreateJointResponse struct {
	Id                   int32    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateJointResponse) Reset()         { *m = CreateJointResponse{} }
func (m *CreateJointResponse) String() string { return proto.CompactTextString(m) }
func (*CreateJointResponse) ProtoMessage()    {}
func (*CreateJointResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{42}
}
func (m *CreateJointResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJointResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJointResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CreateJointResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJointResponse.Merge(dst, src)
}
func (m *CreateJointResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateJointResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJointResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJointResponse proto.InternalMessageInfo

func (m *CreateJointResponse) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type TankSession struct {
	Tank                 string   `protobuf:"bytes,1,opt,name=tank,proto3" json:"tank,omitempty"`
	Conf                 string   `protobuf:"bytes,2,opt,name=conf,proto3" json:"conf,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Failures             []string `protobuf:"bytes,4,rep,name=failures,proto3" json:"failures,omitempty"`
	Stage                string   `protobuf:"bytes,5,opt,name=stage,proto3" json:"stage,omitempty"`
	Status               string   `protobuf:"bytes,6,opt,name=status,proto3" json:"status,omitempty"`
	ExternalId           string   `protobuf:"bytes,7,opt,name=externalId,proto3" json:"externalId,omitempty"`
	OverloadId           int32    `protobuf:"varint,8,opt,name=overloadId,proto3" json:"overloadId,omitempty"`
	ExternalJoint        string   `protobuf:"bytes,9,opt,name=externalJoint,proto3" json:"externalJoint,omitempty"`
	OverloadJoint        int32    `protobuf:"varint,10,opt,name=overloadJoint,proto3" json:"overloadJoint,omitempty"`
	Author               string   `protobuf:"bytes,11,opt,name=author,proto3" json:"author,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TankSession) Reset()         { *m = TankSession{} }
func (m *TankSession) String() string { return proto.CompactTextString(m) }
func (*TankSession) ProtoMessage()    {}
func (*TankSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{43}
}
func (m *TankSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TankSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TankSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TankSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TankSession.Merge(dst, src)
}
func (m *TankSession) XXX_Size() int {
	return m.Size()
}
func (m *TankSession) XXX_DiscardUnknown() {
	xxx_messageInfo_TankSession.DiscardUnknown(m)
}

var xxx_messageInfo_TankSession proto.InternalMessageInfo

func (m *TankSession) GetTank() string {
	if m != nil {
		return m.Tank
	}
	return ""
}

func (m *TankSession) GetConf() string {
	if m != nil {
		return m.Conf
	}
	return ""
}

func (m *TankSession) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TankSession) GetFailures() []string {
	if m != nil {
		return m.Failures
	}
	return nil
}

func (m *TankSession) GetStage() string {
	if m != nil {
		return m.Stage
	}
	return ""
}

func (m *TankSession) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *TankSession) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

func (m *TankSession) GetOverloadId() int32 {
	if m != nil {
		return m.OverloadId
	}
	return 0
}

func (m *TankSession) GetExternalJoint() string {
	if m != nil {
		return m.ExternalJoint
	}
	return ""
}

func (m *TankSession) GetOverloadJoint() int32 {
	if m != nil {
		return m.OverloadJoint
	}
	return 0
}

func (m *TankSession) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

type FirestarterValidateRequest struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterValidateRequest) Reset()         { *m = FirestarterValidateRequest{} }
func (m *FirestarterValidateRequest) String() string { return proto.CompactTextString(m) }
func (*FirestarterValidateRequest) ProtoMessage()    {}
func (*FirestarterValidateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{44}
}
func (m *FirestarterValidateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterValidateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterValidateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterValidateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterValidateRequest.Merge(dst, src)
}
func (m *FirestarterValidateRequest) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterValidateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterValidateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterValidateRequest proto.InternalMessageInfo

func (m *FirestarterValidateRequest) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type FirestarterValidateResponse struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterValidateResponse) Reset()         { *m = FirestarterValidateResponse{} }
func (m *FirestarterValidateResponse) String() string { return proto.CompactTextString(m) }
func (*FirestarterValidateResponse) ProtoMessage()    {}
func (*FirestarterValidateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{45}
}
func (m *FirestarterValidateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterValidateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterValidateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterValidateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterValidateResponse.Merge(dst, src)
}
func (m *FirestarterValidateResponse) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterValidateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterValidateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterValidateResponse proto.InternalMessageInfo

func (m *FirestarterValidateResponse) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type FirestarterPrepareRequest struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterPrepareRequest) Reset()         { *m = FirestarterPrepareRequest{} }
func (m *FirestarterPrepareRequest) String() string { return proto.CompactTextString(m) }
func (*FirestarterPrepareRequest) ProtoMessage()    {}
func (*FirestarterPrepareRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{46}
}
func (m *FirestarterPrepareRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterPrepareRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterPrepareRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterPrepareRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterPrepareRequest.Merge(dst, src)
}
func (m *FirestarterPrepareRequest) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterPrepareRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterPrepareRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterPrepareRequest proto.InternalMessageInfo

func (m *FirestarterPrepareRequest) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type FirestarterPrepareResponse struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterPrepareResponse) Reset()         { *m = FirestarterPrepareResponse{} }
func (m *FirestarterPrepareResponse) String() string { return proto.CompactTextString(m) }
func (*FirestarterPrepareResponse) ProtoMessage()    {}
func (*FirestarterPrepareResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{47}
}
func (m *FirestarterPrepareResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterPrepareResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterPrepareResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterPrepareResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterPrepareResponse.Merge(dst, src)
}
func (m *FirestarterPrepareResponse) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterPrepareResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterPrepareResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterPrepareResponse proto.InternalMessageInfo

func (m *FirestarterPrepareResponse) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type FirestarterRunRequest struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterRunRequest) Reset()         { *m = FirestarterRunRequest{} }
func (m *FirestarterRunRequest) String() string { return proto.CompactTextString(m) }
func (*FirestarterRunRequest) ProtoMessage()    {}
func (*FirestarterRunRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{48}
}
func (m *FirestarterRunRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterRunRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterRunRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterRunRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterRunRequest.Merge(dst, src)
}
func (m *FirestarterRunRequest) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterRunRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterRunRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterRunRequest proto.InternalMessageInfo

func (m *FirestarterRunRequest) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type FirestarterRunResponse struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterRunResponse) Reset()         { *m = FirestarterRunResponse{} }
func (m *FirestarterRunResponse) String() string { return proto.CompactTextString(m) }
func (*FirestarterRunResponse) ProtoMessage()    {}
func (*FirestarterRunResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{49}
}
func (m *FirestarterRunResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterRunResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterRunResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterRunResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterRunResponse.Merge(dst, src)
}
func (m *FirestarterRunResponse) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterRunResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterRunResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterRunResponse proto.InternalMessageInfo

func (m *FirestarterRunResponse) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type FirestarterStopRequest struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterStopRequest) Reset()         { *m = FirestarterStopRequest{} }
func (m *FirestarterStopRequest) String() string { return proto.CompactTextString(m) }
func (*FirestarterStopRequest) ProtoMessage()    {}
func (*FirestarterStopRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{50}
}
func (m *FirestarterStopRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterStopRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterStopRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterStopRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterStopRequest.Merge(dst, src)
}
func (m *FirestarterStopRequest) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterStopRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterStopRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterStopRequest proto.InternalMessageInfo

func (m *FirestarterStopRequest) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type FirestarterStopResponse struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterStopResponse) Reset()         { *m = FirestarterStopResponse{} }
func (m *FirestarterStopResponse) String() string { return proto.CompactTextString(m) }
func (*FirestarterStopResponse) ProtoMessage()    {}
func (*FirestarterStopResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{51}
}
func (m *FirestarterStopResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterStopResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterStopResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterStopResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterStopResponse.Merge(dst, src)
}
func (m *FirestarterStopResponse) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterStopResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterStopResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterStopResponse proto.InternalMessageInfo

func (m *FirestarterStopResponse) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type FirestarterPollRequest struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterPollRequest) Reset()         { *m = FirestarterPollRequest{} }
func (m *FirestarterPollRequest) String() string { return proto.CompactTextString(m) }
func (*FirestarterPollRequest) ProtoMessage()    {}
func (*FirestarterPollRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{52}
}
func (m *FirestarterPollRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterPollRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterPollRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterPollRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterPollRequest.Merge(dst, src)
}
func (m *FirestarterPollRequest) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterPollRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterPollRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterPollRequest proto.InternalMessageInfo

func (m *FirestarterPollRequest) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type FirestarterPollResponse struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterPollResponse) Reset()         { *m = FirestarterPollResponse{} }
func (m *FirestarterPollResponse) String() string { return proto.CompactTextString(m) }
func (*FirestarterPollResponse) ProtoMessage()    {}
func (*FirestarterPollResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{53}
}
func (m *FirestarterPollResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterPollResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterPollResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterPollResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterPollResponse.Merge(dst, src)
}
func (m *FirestarterPollResponse) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterPollResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterPollResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterPollResponse proto.InternalMessageInfo

func (m *FirestarterPollResponse) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type FirestarterTankSessionsRequest struct {
	Tank                 string   `protobuf:"bytes,1,opt,name=tank,proto3" json:"tank,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirestarterTankSessionsRequest) Reset()         { *m = FirestarterTankSessionsRequest{} }
func (m *FirestarterTankSessionsRequest) String() string { return proto.CompactTextString(m) }
func (*FirestarterTankSessionsRequest) ProtoMessage()    {}
func (*FirestarterTankSessionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{54}
}
func (m *FirestarterTankSessionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterTankSessionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterTankSessionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterTankSessionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterTankSessionsRequest.Merge(dst, src)
}
func (m *FirestarterTankSessionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterTankSessionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterTankSessionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterTankSessionsRequest proto.InternalMessageInfo

func (m *FirestarterTankSessionsRequest) GetTank() string {
	if m != nil {
		return m.Tank
	}
	return ""
}

type FirestarterTankSessionsResponse struct {
	Sessions             []*TankSession `protobuf:"bytes,1,rep,name=sessions,proto3" json:"sessions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FirestarterTankSessionsResponse) Reset()         { *m = FirestarterTankSessionsResponse{} }
func (m *FirestarterTankSessionsResponse) String() string { return proto.CompactTextString(m) }
func (*FirestarterTankSessionsResponse) ProtoMessage()    {}
func (*FirestarterTankSessionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_overload_74309234e9e00b12, []int{55}
}
func (m *FirestarterTankSessionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirestarterTankSessionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirestarterTankSessionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FirestarterTankSessionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirestarterTankSessionsResponse.Merge(dst, src)
}
func (m *FirestarterTankSessionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *FirestarterTankSessionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FirestarterTankSessionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FirestarterTankSessionsResponse proto.InternalMessageInfo

func (m *FirestarterTankSessionsResponse) GetSessions() []*TankSession {
	if m != nil {
		return m.Sessions
	}
	return nil
}

func init() {
	proto.RegisterType((*Job)(nil), "Job")
	proto.RegisterType((*Collection)(nil), "Collection")
	proto.RegisterType((*CreateJobRequest)(nil), "CreateJobRequest")
	proto.RegisterType((*CreateJobResponse)(nil), "CreateJobResponse")
	proto.RegisterType((*JobRequest)(nil), "JobRequest")
	proto.RegisterType((*JobResponse)(nil), "JobResponse")
	proto.RegisterType((*LastJobsRequest)(nil), "LastJobsRequest")
	proto.RegisterType((*LastJobsResponse)(nil), "LastJobsResponse")
	proto.RegisterType((*GetJobParamsRequest)(nil), "GetJobParamsRequest")
	proto.RegisterType((*GetJobParamsResponse)(nil), "GetJobParamsResponse")
	proto.RegisterType((*UpdateJobRequest)(nil), "UpdateJobRequest")
	proto.RegisterType((*UpdateJobResponse)(nil), "UpdateJobResponse")
	proto.RegisterType((*DeleteJobRequest)(nil), "DeleteJobRequest")
	proto.RegisterType((*DeleteJobResponse)(nil), "DeleteJobResponse")
	proto.RegisterType((*JobAggregate)(nil), "JobAggregate")
	proto.RegisterType((*CreateAggregatesRequest)(nil), "CreateAggregatesRequest")
	proto.RegisterType((*CreateAggregatesResponse)(nil), "CreateAggregatesResponse")
	proto.RegisterType((*GetAggregatesRequest)(nil), "GetAggregatesRequest")
	proto.RegisterType((*GetAggregatesResponse)(nil), "GetAggregatesResponse")
	proto.RegisterType((*GetCollectionsRequest)(nil), "GetCollectionsRequest")
	proto.RegisterType((*GetCollectionsResponse)(nil), "GetCollectionsResponse")
	proto.RegisterType((*GetCollectionParamsRequest)(nil), "GetCollectionParamsRequest")
	proto.RegisterType((*GetCollectionParamsResponse)(nil), "GetCollectionParamsResponse")
	proto.RegisterType((*Project)(nil), "Project")
	proto.RegisterType((*Ammo)(nil), "Ammo")
	proto.RegisterType((*UploadAmmoRequest)(nil), "UploadAmmoRequest")
	proto.RegisterType((*UploadAmmoResponse)(nil), "UploadAmmoResponse")
	proto.RegisterType((*ListAmmoRequest)(nil), "ListAmmoRequest")
	proto.RegisterType((*ListAmmoResponse)(nil), "ListAmmoResponse")
	proto.RegisterType((*DeleteAmmoRequest)(nil), "DeleteAmmoRequest")
	proto.RegisterType((*DeleteAmmoResponse)(nil), "DeleteAmmoResponse")
	proto.RegisterType((*Artifact)(nil), "Artifact")
	proto.RegisterType((*UploadArtifactRequest)(nil), "UploadArtifactRequest")
	proto.RegisterType((*UploadArtifactResponse)(nil), "UploadArtifactResponse")
	proto.RegisterType((*ListArtifactsRequest)(nil), "ListArtifactsRequest")
	proto.RegisterType((*ListArtifactsResponse)(nil), "ListArtifactsResponse")
	proto.RegisterType((*Joint)(nil), "Joint")
	proto.RegisterType((*ListJointsRequest)(nil), "ListJointsRequest")
	proto.RegisterType((*ListJointsResponse)(nil), "ListJointsResponse")
	proto.RegisterType((*GetJointRequest)(nil), "GetJointRequest")
	proto.RegisterType((*GetJointResponse)(nil), "GetJointResponse")
	proto.RegisterType((*CreateJointRequest)(nil), "CreateJointRequest")
	proto.RegisterType((*CreateJointResponse)(nil), "CreateJointResponse")
	proto.RegisterType((*TankSession)(nil), "TankSession")
	proto.RegisterType((*FirestarterValidateRequest)(nil), "FirestarterValidateRequest")
	proto.RegisterType((*FirestarterValidateResponse)(nil), "FirestarterValidateResponse")
	proto.RegisterType((*FirestarterPrepareRequest)(nil), "FirestarterPrepareRequest")
	proto.RegisterType((*FirestarterPrepareResponse)(nil), "FirestarterPrepareResponse")
	proto.RegisterType((*FirestarterRunRequest)(nil), "FirestarterRunRequest")
	proto.RegisterType((*FirestarterRunResponse)(nil), "FirestarterRunResponse")
	proto.RegisterType((*FirestarterStopRequest)(nil), "FirestarterStopRequest")
	proto.RegisterType((*FirestarterStopResponse)(nil), "FirestarterStopResponse")
	proto.RegisterType((*FirestarterPollRequest)(nil), "FirestarterPollRequest")
	proto.RegisterType((*FirestarterPollResponse)(nil), "FirestarterPollResponse")
	proto.RegisterType((*FirestarterTankSessionsRequest)(nil), "FirestarterTankSessionsRequest")
	proto.RegisterType((*FirestarterTankSessionsResponse)(nil), "FirestarterTankSessionsResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OverloadServiceClient is the client API for OverloadService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OverloadServiceClient interface {
	// Jobs
	CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*CreateJobResponse, error)
	GetJob(ctx context.Context, in *JobRequest, opts ...grpc.CallOption) (*JobResponse, error)
	GetLastJobs(ctx context.Context, in *LastJobsRequest, opts ...grpc.CallOption) (*LastJobsResponse, error)
	GetJobParams(ctx context.Context, in *GetJobParamsRequest, opts ...grpc.CallOption) (*GetJobParamsResponse, error)
	UpdateJob(ctx context.Context, in *UpdateJobRequest, opts ...grpc.CallOption) (*UpdateJobResponse, error)
	DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*DeleteJobResponse, error)
	// Aggregates
	CreateAggregates(ctx context.Context, in *CreateAggregatesRequest, opts ...grpc.CallOption) (*CreateAggregatesResponse, error)
	GetAggregates(ctx context.Context, in *GetAggregatesRequest, opts ...grpc.CallOption) (*GetAggregatesResponse, error)
	GetCollections(ctx context.Context, in *GetCollectionsRequest, opts ...grpc.CallOption) (*GetCollectionsResponse, error)
	GetCollectionParams(ctx context.Context, in *GetCollectionParamsRequest, opts ...grpc.CallOption) (*GetCollectionParamsResponse, error)
	// Ammo
	UploadAmmo(ctx context.Context, in *UploadAmmoRequest, opts ...grpc.CallOption) (*UploadAmmoResponse, error)
	ListAmmo(ctx context.Context, in *ListAmmoRequest, opts ...grpc.CallOption) (*ListAmmoResponse, error)
	DeleteAmmo(ctx context.Context, in *DeleteAmmoRequest, opts ...grpc.CallOption) (*DeleteAmmoResponse, error)
	// Artifacts
	UploadArtifact(ctx context.Context, in *UploadArtifactRequest, opts ...grpc.CallOption) (*UploadArtifactResponse, error)
	ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error)
	// Joints
	ListJoints(ctx context.Context, in *ListJointsRequest, opts ...grpc.CallOption) (*ListJointsResponse, error)
	GetJoint(ctx context.Context, in *GetJointRequest, opts ...grpc.CallOption) (*GetJointResponse, error)
	CreateJoint(ctx context.Context, in *CreateJointRequest, opts ...grpc.CallOption) (*CreateJointResponse, error)
	FirestarterValidate(ctx context.Context, in *FirestarterValidateRequest, opts ...grpc.CallOption) (*FirestarterValidateResponse, error)
	FirestarterPrepare(ctx context.Context, in *FirestarterPrepareRequest, opts ...grpc.CallOption) (*FirestarterPrepareResponse, error)
	FirestarterRun(ctx context.Context, in *FirestarterRunRequest, opts ...grpc.CallOption) (*FirestarterRunResponse, error)
	FirestarterStop(ctx context.Context, in *FirestarterStopRequest, opts ...grpc.CallOption) (*FirestarterStopResponse, error)
	FirestarterPoll(ctx context.Context, in *FirestarterPollRequest, opts ...grpc.CallOption) (*FirestarterPollResponse, error)
	FirestarterTankSessions(ctx context.Context, in *FirestarterTankSessionsRequest, opts ...grpc.CallOption) (*FirestarterTankSessionsResponse, error)
}

type overloadServiceClient struct {
	cc *grpc.ClientConn
}

func NewOverloadServiceClient(cc *grpc.ClientConn) OverloadServiceClient {
	return &overloadServiceClient{cc}
}

func (c *overloadServiceClient) CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*CreateJobResponse, error) {
	out := new(CreateJobResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/CreateJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) GetJob(ctx context.Context, in *JobRequest, opts ...grpc.CallOption) (*JobResponse, error) {
	out := new(JobResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/GetJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) GetLastJobs(ctx context.Context, in *LastJobsRequest, opts ...grpc.CallOption) (*LastJobsResponse, error) {
	out := new(LastJobsResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/GetLastJobs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) GetJobParams(ctx context.Context, in *GetJobParamsRequest, opts ...grpc.CallOption) (*GetJobParamsResponse, error) {
	out := new(GetJobParamsResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/GetJobParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) UpdateJob(ctx context.Context, in *UpdateJobRequest, opts ...grpc.CallOption) (*UpdateJobResponse, error) {
	out := new(UpdateJobResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/UpdateJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*DeleteJobResponse, error) {
	out := new(DeleteJobResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/DeleteJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) CreateAggregates(ctx context.Context, in *CreateAggregatesRequest, opts ...grpc.CallOption) (*CreateAggregatesResponse, error) {
	out := new(CreateAggregatesResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/CreateAggregates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) GetAggregates(ctx context.Context, in *GetAggregatesRequest, opts ...grpc.CallOption) (*GetAggregatesResponse, error) {
	out := new(GetAggregatesResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/GetAggregates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) GetCollections(ctx context.Context, in *GetCollectionsRequest, opts ...grpc.CallOption) (*GetCollectionsResponse, error) {
	out := new(GetCollectionsResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/GetCollections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) GetCollectionParams(ctx context.Context, in *GetCollectionParamsRequest, opts ...grpc.CallOption) (*GetCollectionParamsResponse, error) {
	out := new(GetCollectionParamsResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/GetCollectionParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) UploadAmmo(ctx context.Context, in *UploadAmmoRequest, opts ...grpc.CallOption) (*UploadAmmoResponse, error) {
	out := new(UploadAmmoResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/UploadAmmo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) ListAmmo(ctx context.Context, in *ListAmmoRequest, opts ...grpc.CallOption) (*ListAmmoResponse, error) {
	out := new(ListAmmoResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/ListAmmo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) DeleteAmmo(ctx context.Context, in *DeleteAmmoRequest, opts ...grpc.CallOption) (*DeleteAmmoResponse, error) {
	out := new(DeleteAmmoResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/DeleteAmmo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) UploadArtifact(ctx context.Context, in *UploadArtifactRequest, opts ...grpc.CallOption) (*UploadArtifactResponse, error) {
	out := new(UploadArtifactResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/UploadArtifact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error) {
	out := new(ListArtifactsResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/ListArtifacts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) ListJoints(ctx context.Context, in *ListJointsRequest, opts ...grpc.CallOption) (*ListJointsResponse, error) {
	out := new(ListJointsResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/ListJoints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) GetJoint(ctx context.Context, in *GetJointRequest, opts ...grpc.CallOption) (*GetJointResponse, error) {
	out := new(GetJointResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/GetJoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) CreateJoint(ctx context.Context, in *CreateJointRequest, opts ...grpc.CallOption) (*CreateJointResponse, error) {
	out := new(CreateJointResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/CreateJoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) FirestarterValidate(ctx context.Context, in *FirestarterValidateRequest, opts ...grpc.CallOption) (*FirestarterValidateResponse, error) {
	out := new(FirestarterValidateResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/FirestarterValidate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) FirestarterPrepare(ctx context.Context, in *FirestarterPrepareRequest, opts ...grpc.CallOption) (*FirestarterPrepareResponse, error) {
	out := new(FirestarterPrepareResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/FirestarterPrepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) FirestarterRun(ctx context.Context, in *FirestarterRunRequest, opts ...grpc.CallOption) (*FirestarterRunResponse, error) {
	out := new(FirestarterRunResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/FirestarterRun", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) FirestarterStop(ctx context.Context, in *FirestarterStopRequest, opts ...grpc.CallOption) (*FirestarterStopResponse, error) {
	out := new(FirestarterStopResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/FirestarterStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) FirestarterPoll(ctx context.Context, in *FirestarterPollRequest, opts ...grpc.CallOption) (*FirestarterPollResponse, error) {
	out := new(FirestarterPollResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/FirestarterPoll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overloadServiceClient) FirestarterTankSessions(ctx context.Context, in *FirestarterTankSessionsRequest, opts ...grpc.CallOption) (*FirestarterTankSessionsResponse, error) {
	out := new(FirestarterTankSessionsResponse)
	err := c.cc.Invoke(ctx, "/OverloadService/FirestarterTankSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OverloadServiceServer is the server API for OverloadService service.
type OverloadServiceServer interface {
	// Jobs
	CreateJob(context.Context, *CreateJobRequest) (*CreateJobResponse, error)
	GetJob(context.Context, *JobRequest) (*JobResponse, error)
	GetLastJobs(context.Context, *LastJobsRequest) (*LastJobsResponse, error)
	GetJobParams(context.Context, *GetJobParamsRequest) (*GetJobParamsResponse, error)
	UpdateJob(context.Context, *UpdateJobRequest) (*UpdateJobResponse, error)
	DeleteJob(context.Context, *DeleteJobRequest) (*DeleteJobResponse, error)
	// Aggregates
	CreateAggregates(context.Context, *CreateAggregatesRequest) (*CreateAggregatesResponse, error)
	GetAggregates(context.Context, *GetAggregatesRequest) (*GetAggregatesResponse, error)
	GetCollections(context.Context, *GetCollectionsRequest) (*GetCollectionsResponse, error)
	GetCollectionParams(context.Context, *GetCollectionParamsRequest) (*GetCollectionParamsResponse, error)
	// Ammo
	UploadAmmo(context.Context, *UploadAmmoRequest) (*UploadAmmoResponse, error)
	ListAmmo(context.Context, *ListAmmoRequest) (*ListAmmoResponse, error)
	DeleteAmmo(context.Context, *DeleteAmmoRequest) (*DeleteAmmoResponse, error)
	// Artifacts
	UploadArtifact(context.Context, *UploadArtifactRequest) (*UploadArtifactResponse, error)
	ListArtifacts(context.Context, *ListArtifactsRequest) (*ListArtifactsResponse, error)
	// Joints
	ListJoints(context.Context, *ListJointsRequest) (*ListJointsResponse, error)
	GetJoint(context.Context, *GetJointRequest) (*GetJointResponse, error)
	CreateJoint(context.Context, *CreateJointRequest) (*CreateJointResponse, error)
	FirestarterValidate(context.Context, *FirestarterValidateRequest) (*FirestarterValidateResponse, error)
	FirestarterPrepare(context.Context, *FirestarterPrepareRequest) (*FirestarterPrepareResponse, error)
	FirestarterRun(context.Context, *FirestarterRunRequest) (*FirestarterRunResponse, error)
	FirestarterStop(context.Context, *FirestarterStopRequest) (*FirestarterStopResponse, error)
	FirestarterPoll(context.Context, *FirestarterPollRequest) (*FirestarterPollResponse, error)
	FirestarterTankSessions(context.Context, *FirestarterTankSessionsRequest) (*FirestarterTankSessionsResponse, error)
}

func RegisterOverloadServiceServer(s *grpc.Server, srv OverloadServiceServer) {
	s.RegisterService(&_OverloadService_serviceDesc, srv)
}

func _OverloadService_CreateJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).CreateJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/CreateJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).CreateJob(ctx, req.(*CreateJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/GetJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).GetJob(ctx, req.(*JobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_GetLastJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LastJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).GetLastJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/GetLastJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).GetLastJobs(ctx, req.(*LastJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_GetJobParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).GetJobParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/GetJobParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).GetJobParams(ctx, req.(*GetJobParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_UpdateJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).UpdateJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/UpdateJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).UpdateJob(ctx, req.(*UpdateJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/DeleteJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).DeleteJob(ctx, req.(*DeleteJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_CreateAggregates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAggregatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).CreateAggregates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/CreateAggregates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).CreateAggregates(ctx, req.(*CreateAggregatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_GetAggregates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAggregatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).GetAggregates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/GetAggregates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).GetAggregates(ctx, req.(*GetAggregatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_GetCollections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).GetCollections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/GetCollections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).GetCollections(ctx, req.(*GetCollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_GetCollectionParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).GetCollectionParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/GetCollectionParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).GetCollectionParams(ctx, req.(*GetCollectionParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_UploadAmmo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadAmmoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).UploadAmmo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/UploadAmmo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).UploadAmmo(ctx, req.(*UploadAmmoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_ListAmmo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAmmoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).ListAmmo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/ListAmmo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).ListAmmo(ctx, req.(*ListAmmoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_DeleteAmmo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAmmoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).DeleteAmmo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/DeleteAmmo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).DeleteAmmo(ctx, req.(*DeleteAmmoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_UploadArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).UploadArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/UploadArtifact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).UploadArtifact(ctx, req.(*UploadArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_ListArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).ListArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/ListArtifacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).ListArtifacts(ctx, req.(*ListArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_ListJoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJointsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).ListJoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/ListJoints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).ListJoints(ctx, req.(*ListJointsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_GetJoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).GetJoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/GetJoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).GetJoint(ctx, req.(*GetJointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_CreateJoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateJointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).CreateJoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/CreateJoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).CreateJoint(ctx, req.(*CreateJointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_FirestarterValidate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirestarterValidateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).FirestarterValidate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/FirestarterValidate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).FirestarterValidate(ctx, req.(*FirestarterValidateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_FirestarterPrepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirestarterPrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).FirestarterPrepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/FirestarterPrepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).FirestarterPrepare(ctx, req.(*FirestarterPrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_FirestarterRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirestarterRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).FirestarterRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/FirestarterRun",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).FirestarterRun(ctx, req.(*FirestarterRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_FirestarterStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirestarterStopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).FirestarterStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/FirestarterStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).FirestarterStop(ctx, req.(*FirestarterStopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_FirestarterPoll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirestarterPollRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).FirestarterPoll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/FirestarterPoll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).FirestarterPoll(ctx, req.(*FirestarterPollRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OverloadService_FirestarterTankSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirestarterTankSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverloadServiceServer).FirestarterTankSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/OverloadService/FirestarterTankSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverloadServiceServer).FirestarterTankSessions(ctx, req.(*FirestarterTankSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OverloadService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "OverloadService",
	HandlerType: (*OverloadServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateJob",
			Handler:    _OverloadService_CreateJob_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _OverloadService_GetJob_Handler,
		},
		{
			MethodName: "GetLastJobs",
			Handler:    _OverloadService_GetLastJobs_Handler,
		},
		{
			MethodName: "GetJobParams",
			Handler:    _OverloadService_GetJobParams_Handler,
		},
		{
			MethodName: "UpdateJob",
			Handler:    _OverloadService_UpdateJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _OverloadService_DeleteJob_Handler,
		},
		{
			MethodName: "CreateAggregates",
			Handler:    _OverloadService_CreateAggregates_Handler,
		},
		{
			MethodName: "GetAggregates",
			Handler:    _OverloadService_GetAggregates_Handler,
		},
		{
			MethodName: "GetCollections",
			Handler:    _OverloadService_GetCollections_Handler,
		},
		{
			MethodName: "GetCollectionParams",
			Handler:    _OverloadService_GetCollectionParams_Handler,
		},
		{
			MethodName: "UploadAmmo",
			Handler:    _OverloadService_UploadAmmo_Handler,
		},
		{
			MethodName: "ListAmmo",
			Handler:    _OverloadService_ListAmmo_Handler,
		},
		{
			MethodName: "DeleteAmmo",
			Handler:    _OverloadService_DeleteAmmo_Handler,
		},
		{
			MethodName: "UploadArtifact",
			Handler:    _OverloadService_UploadArtifact_Handler,
		},
		{
			MethodName: "ListArtifacts",
			Handler:    _OverloadService_ListArtifacts_Handler,
		},
		{
			MethodName: "ListJoints",
			Handler:    _OverloadService_ListJoints_Handler,
		},
		{
			MethodName: "GetJoint",
			Handler:    _OverloadService_GetJoint_Handler,
		},
		{
			MethodName: "CreateJoint",
			Handler:    _OverloadService_CreateJoint_Handler,
		},
		{
			MethodName: "FirestarterValidate",
			Handler:    _OverloadService_FirestarterValidate_Handler,
		},
		{
			MethodName: "FirestarterPrepare",
			Handler:    _OverloadService_FirestarterPrepare_Handler,
		},
		{
			MethodName: "FirestarterRun",
			Handler:    _OverloadService_FirestarterRun_Handler,
		},
		{
			MethodName: "FirestarterStop",
			Handler:    _OverloadService_FirestarterStop_Handler,
		},
		{
			MethodName: "FirestarterPoll",
			Handler:    _OverloadService_FirestarterPoll_Handler,
		},
		{
			MethodName: "FirestarterTankSessions",
			Handler:    _OverloadService_FirestarterTankSessions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "overload.proto",
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if m.TestStart != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestStart))))
		i += 8
	}
	if m.TestStop != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestStop))))
		i += 8
	}
	if len(m.Config) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Config)))
		i += copy(dAtA[i:], m.Config)
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if len(m.RegressionId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.RegressionId)))
		i += copy(dAtA[i:], m.RegressionId)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Tank) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Tank)))
		i += copy(dAtA[i:], m.Tank)
	}
	if len(m.Target) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if len(m.EnvironmentDetails) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.EnvironmentDetails)))
		i += copy(dAtA[i:], m.EnvironmentDetails)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.AutostopTime != 0 {
		dAtA[i] = 0x61
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AutostopTime))))
		i += 8
	}
	if len(m.AutostopMessage) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.AutostopMessage)))
		i += copy(dAtA[i:], m.AutostopMessage)
	}
	if m.Imbalance != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Imbalance))
	}
	if len(m.Collections) > 0 {
		for _, msg := range m.Collections {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Collection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Collection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if len(m.Env) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Env)))
		i += copy(dAtA[i:], m.Env)
	}
	if len(m.Project) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Project)))
		i += copy(dAtA[i:], m.Project)
	}
	if len(m.Service) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Service)))
		i += copy(dAtA[i:], m.Service)
	}
	if len(m.Ref) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Ref)))
		i += copy(dAtA[i:], m.Ref)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.LatestJobs) > 0 {
		for _, msg := range m.LatestJobs {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TestStart != 0 {
		dAtA[i] = 0x9
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestStart))))
		i += 8
	}
	if m.TestStop != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestStop))))
		i += 8
	}
	if len(m.Config) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Config)))
		i += copy(dAtA[i:], m.Config)
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if len(m.RegressionId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.RegressionId)))
		i += copy(dAtA[i:], m.RegressionId)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Tank) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Tank)))
		i += copy(dAtA[i:], m.Tank)
	}
	if len(m.Target) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if len(m.EnvironmentDetails) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.EnvironmentDetails)))
		i += copy(dAtA[i:], m.EnvironmentDetails)
	}
	if len(m.Collections) > 0 {
		for _, msg := range m.Collections {
			dAtA[i] = 0x52
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *JobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *JobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Job.Size()))
		n1, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LastJobsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastJobsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Page) > 0 {
		for _, s := range m.Page {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Limit) > 0 {
		for _, s := range m.Limit {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Author) > 0 {
		for _, s := range m.Author {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Status) > 0 {
		for _, s := range m.Status {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Target) > 0 {
		for _, s := range m.Target {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Description) > 0 {
		for _, s := range m.Description {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LastJobsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastJobsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, msg := range m.Jobs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetJobParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetJobParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetJobParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetJobParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Authors) > 0 {
		for _, s := range m.Authors {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Statuses) > 0 {
		for _, s := range m.Statuses {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Targets) > 0 {
		for _, s := range m.Targets {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if m.TestStart != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestStart))))
		i += 8
	}
	if m.TestStop != 0 {
		dAtA[i] = 0x19
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TestStop))))
		i += 8
	}
	if len(m.Config) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Config)))
		i += copy(dAtA[i:], m.Config)
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if len(m.RegressionId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.RegressionId)))
		i += copy(dAtA[i:], m.RegressionId)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Tank) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Tank)))
		i += copy(dAtA[i:], m.Tank)
	}
	if len(m.Target) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if len(m.EnvironmentDetails) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.EnvironmentDetails)))
		i += copy(dAtA[i:], m.EnvironmentDetails)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if m.AutostopTime != 0 {
		dAtA[i] = 0x61
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AutostopTime))))
		i += 8
	}
	if len(m.AutostopMessage) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.AutostopMessage)))
		i += copy(dAtA[i:], m.AutostopMessage)
	}
	if m.Imbalance != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Imbalance))
	}
	if len(m.Collections) > 0 {
		dAtA3 := make([]byte, len(m.Collections)*10)
		var j2 int
		for _, num1 := range m.Collections {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x7a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateJobResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteJobResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *JobAggregate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobAggregate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if len(m.Label) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if m.Q50 != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q50))))
		i += 4
	}
	if m.Q75 != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q75))))
		i += 4
	}
	if m.Q80 != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q80))))
		i += 4
	}
	if m.Q85 != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q85))))
		i += 4
	}
	if m.Q90 != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q90))))
		i += 4
	}
	if m.Q95 != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q95))))
		i += 4
	}
	if m.Q98 != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q98))))
		i += 4
	}
	if m.Q99 != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q99))))
		i += 4
	}
	if m.Q100 != 0 {
		dAtA[i] = 0x5d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q100))))
		i += 4
	}
	if m.Avg != 0 {
		dAtA[i] = 0x65
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Avg))))
		i += 4
	}
	if len(m.ResponseCode) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.ResponseCode)))
		i += copy(dAtA[i:], m.ResponseCode)
	}
	if m.OkCount != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.OkCount))
	}
	if m.ErrCount != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.ErrCount))
	}
	if m.NetRecv != 0 {
		dAtA[i] = 0x85
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetRecv))))
		i += 4
	}
	if m.NetSend != 0 {
		dAtA[i] = 0x8d
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetSend))))
		i += 4
	}
	if m.JobId != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.JobId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateAggregatesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAggregatesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if m.Q50 != 0 {
		dAtA[i] = 0x15
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q50))))
		i += 4
	}
	if m.Q75 != 0 {
		dAtA[i] = 0x1d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q75))))
		i += 4
	}
	if m.Q80 != 0 {
		dAtA[i] = 0x25
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q80))))
		i += 4
	}
	if m.Q85 != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q85))))
		i += 4
	}
	if m.Q90 != 0 {
		dAtA[i] = 0x35
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q90))))
		i += 4
	}
	if m.Q95 != 0 {
		dAtA[i] = 0x3d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q95))))
		i += 4
	}
	if m.Q98 != 0 {
		dAtA[i] = 0x45
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q98))))
		i += 4
	}
	if m.Q99 != 0 {
		dAtA[i] = 0x4d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q99))))
		i += 4
	}
	if m.Q100 != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Q100))))
		i += 4
	}
	if m.Avg != 0 {
		dAtA[i] = 0x5d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Avg))))
		i += 4
	}
	if len(m.ResponseCode) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.ResponseCode)))
		i += copy(dAtA[i:], m.ResponseCode)
	}
	if m.OkCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.OkCount))
	}
	if m.ErrCount != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.ErrCount))
	}
	if m.NetRecv != 0 {
		dAtA[i] = 0x7d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetRecv))))
		i += 4
	}
	if m.NetSend != 0 {
		dAtA[i] = 0x85
		i++
		dAtA[i] = 0x1
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NetSend))))
		i += 4
	}
	if m.JobId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.JobId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateAggregatesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAggregatesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAggregatesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAggregatesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TestId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.TestId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAggregatesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAggregatesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Aggregates) > 0 {
		for _, msg := range m.Aggregates {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetCollectionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCollectionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Page) > 0 {
		for _, s := range m.Page {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Limit) > 0 {
		for _, s := range m.Limit {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CollectionId) > 0 {
		dAtA5 := make([]byte, len(m.CollectionId)*10)
		var j4 int
		for _, num1 := range m.CollectionId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Project) > 0 {
		for _, s := range m.Project {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Ref) > 0 {
		for _, s := range m.Ref {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Name) > 0 {
		for _, s := range m.Name {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetCollectionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCollectionsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Collections) > 0 {
		for _, msg := range m.Collections {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetCollectionParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCollectionParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetCollectionParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCollectionParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Envs) > 0 {
		for _, s := range m.Envs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Projects) > 0 {
		for _, msg := range m.Projects {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Refs) > 0 {
		for _, s := range m.Refs {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Project) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Project) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Project) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Project)))
		i += copy(dAtA[i:], m.Project)
	}
	if len(m.Service) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Service)))
		i += copy(dAtA[i:], m.Service)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Ammo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ammo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Etag) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Etag)))
		i += copy(dAtA[i:], m.Etag)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.LastModified) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.LastModified)))
		i += copy(dAtA[i:], m.LastModified)
	}
	if m.LastUsed != 0 {
		dAtA[i] = 0x21
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.LastUsed))))
		i += 8
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Size_))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadAmmoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadAmmoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.File) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.File)))
		i += copy(dAtA[i:], m.File)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadAmmoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadAmmoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListAmmoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAmmoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListAmmoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAmmoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ammo) > 0 {
		for _, msg := range m.Ammo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteAmmoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAmmoRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteAmmoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAmmoResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Artifact) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Artifact) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Etag) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Etag)))
		i += copy(dAtA[i:], m.Etag)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.LastModified) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.LastModified)))
		i += copy(dAtA[i:], m.LastModified)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Size_))
	}
	if len(m.Path) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Job != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Job))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadArtifactRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadArtifactRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Job) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Job)))
		i += copy(dAtA[i:], m.Job)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.File) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.File)))
		i += copy(dAtA[i:], m.File)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadArtifactResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadArtifactResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListArtifactsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListArtifactsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Job))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListArtifactsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListArtifactsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Artifacts) > 0 {
		for _, msg := range m.Artifacts {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Joint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Joint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if len(m.Jobs) > 0 {
		for _, msg := range m.Jobs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListJointsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJointsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListJointsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJointsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Joints) > 0 {
		for _, msg := range m.Joints {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetJointRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetJointRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetJointResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetJointResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Joint != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Joint.Size()))
		n6, err := m.Joint.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateJointRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJointRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		dAtA8 := make([]byte, len(m.Jobs)*10)
		var j7 int
		for _, num1 := range m.Jobs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateJointResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJointResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TankSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TankSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tank) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Tank)))
		i += copy(dAtA[i:], m.Tank)
	}
	if len(m.Conf) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Conf)))
		i += copy(dAtA[i:], m.Conf)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Failures) > 0 {
		for _, s := range m.Failures {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Stage) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Stage)))
		i += copy(dAtA[i:], m.Stage)
	}
	if len(m.Status) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Status)))
		i += copy(dAtA[i:], m.Status)
	}
	if len(m.ExternalId) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.ExternalId)))
		i += copy(dAtA[i:], m.ExternalId)
	}
	if m.OverloadId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.OverloadId))
	}
	if len(m.ExternalJoint) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.ExternalJoint)))
		i += copy(dAtA[i:], m.ExternalJoint)
	}
	if m.OverloadJoint != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintOverload(dAtA, i, uint64(m.OverloadJoint))
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterValidateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterValidateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterValidateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterValidateResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterPrepareRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterPrepareRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterPrepareResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterPrepareResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterRunRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterRunRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterRunResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterRunResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterStopRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterStopRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterStopResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterStopResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterPollRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterPollRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterPollResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterPollResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterTankSessionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterTankSessionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tank) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintOverload(dAtA, i, uint64(len(m.Tank)))
		i += copy(dAtA[i:], m.Tank)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FirestarterTankSessionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirestarterTankSessionsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintOverload(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintOverload(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	if m.TestStart != 0 {
		n += 9
	}
	if m.TestStop != 0 {
		n += 9
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.RegressionId)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Tank)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.EnvironmentDetails)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.AutostopTime != 0 {
		n += 9
	}
	l = len(m.AutostopMessage)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.Imbalance != 0 {
		n += 1 + sovOverload(uint64(m.Imbalance))
	}
	if len(m.Collections) > 0 {
		for _, e := range m.Collections {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Collection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	l = len(m.Env)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Project)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Ref)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if len(m.LatestJobs) > 0 {
		for _, e := range m.LatestJobs {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestStart != 0 {
		n += 9
	}
	if m.TestStop != 0 {
		n += 9
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.RegressionId)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Tank)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.EnvironmentDetails)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if len(m.Collections) > 0 {
		for _, e := range m.Collections {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LastJobsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Page) > 0 {
		for _, s := range m.Page {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Limit) > 0 {
		for _, s := range m.Limit {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Author) > 0 {
		for _, s := range m.Author {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Status) > 0 {
		for _, s := range m.Status {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Target) > 0 {
		for _, s := range m.Target {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Description) > 0 {
		for _, s := range m.Description {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LastJobsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovOverload(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetJobParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetJobParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Authors) > 0 {
		for _, s := range m.Authors {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Statuses) > 0 {
		for _, s := range m.Statuses {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Targets) > 0 {
		for _, s := range m.Targets {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	if m.TestStart != 0 {
		n += 9
	}
	if m.TestStop != 0 {
		n += 9
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.RegressionId)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Tank)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.EnvironmentDetails)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.AutostopTime != 0 {
		n += 9
	}
	l = len(m.AutostopMessage)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.Imbalance != 0 {
		n += 1 + sovOverload(uint64(m.Imbalance))
	}
	if len(m.Collections) > 0 {
		l = 0
		for _, e := range m.Collections {
			l += sovOverload(uint64(e))
		}
		n += 1 + sovOverload(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobAggregate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.Q50 != 0 {
		n += 5
	}
	if m.Q75 != 0 {
		n += 5
	}
	if m.Q80 != 0 {
		n += 5
	}
	if m.Q85 != 0 {
		n += 5
	}
	if m.Q90 != 0 {
		n += 5
	}
	if m.Q95 != 0 {
		n += 5
	}
	if m.Q98 != 0 {
		n += 5
	}
	if m.Q99 != 0 {
		n += 5
	}
	if m.Q100 != 0 {
		n += 5
	}
	if m.Avg != 0 {
		n += 5
	}
	l = len(m.ResponseCode)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.OkCount != 0 {
		n += 1 + sovOverload(uint64(m.OkCount))
	}
	if m.ErrCount != 0 {
		n += 1 + sovOverload(uint64(m.ErrCount))
	}
	if m.NetRecv != 0 {
		n += 6
	}
	if m.NetSend != 0 {
		n += 6
	}
	if m.JobId != 0 {
		n += 2 + sovOverload(uint64(m.JobId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateAggregatesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.Q50 != 0 {
		n += 5
	}
	if m.Q75 != 0 {
		n += 5
	}
	if m.Q80 != 0 {
		n += 5
	}
	if m.Q85 != 0 {
		n += 5
	}
	if m.Q90 != 0 {
		n += 5
	}
	if m.Q95 != 0 {
		n += 5
	}
	if m.Q98 != 0 {
		n += 5
	}
	if m.Q99 != 0 {
		n += 5
	}
	if m.Q100 != 0 {
		n += 5
	}
	if m.Avg != 0 {
		n += 5
	}
	l = len(m.ResponseCode)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.OkCount != 0 {
		n += 1 + sovOverload(uint64(m.OkCount))
	}
	if m.ErrCount != 0 {
		n += 1 + sovOverload(uint64(m.ErrCount))
	}
	if m.NetRecv != 0 {
		n += 5
	}
	if m.NetSend != 0 {
		n += 6
	}
	if m.JobId != 0 {
		n += 2 + sovOverload(uint64(m.JobId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateAggregatesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAggregatesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestId != 0 {
		n += 1 + sovOverload(uint64(m.TestId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAggregatesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Aggregates) > 0 {
		for _, e := range m.Aggregates {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCollectionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Page) > 0 {
		for _, s := range m.Page {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Limit) > 0 {
		for _, s := range m.Limit {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.CollectionId) > 0 {
		l = 0
		for _, e := range m.CollectionId {
			l += sovOverload(uint64(e))
		}
		n += 1 + sovOverload(uint64(l)) + l
	}
	if len(m.Env) > 0 {
		for _, s := range m.Env {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Project) > 0 {
		for _, s := range m.Project {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Ref) > 0 {
		for _, s := range m.Ref {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Name) > 0 {
		for _, s := range m.Name {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCollectionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Collections) > 0 {
		for _, e := range m.Collections {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovOverload(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCollectionParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCollectionParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Envs) > 0 {
		for _, s := range m.Envs {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Projects) > 0 {
		for _, e := range m.Projects {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Refs) > 0 {
		for _, s := range m.Refs {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Project) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Project)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Ammo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Etag)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.LastModified)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.LastUsed != 0 {
		n += 9
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovOverload(uint64(m.Size_))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadAmmoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadAmmoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAmmoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAmmoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ammo) > 0 {
		for _, e := range m.Ammo {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteAmmoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteAmmoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Artifact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Etag)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.LastModified)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovOverload(uint64(m.Size_))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.Job != 0 {
		n += 1 + sovOverload(uint64(m.Job))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadArtifactRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Job)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadArtifactResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListArtifactsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != 0 {
		n += 1 + sovOverload(uint64(m.Job))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListArtifactsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Artifacts) > 0 {
		for _, e := range m.Artifacts {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Joint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListJointsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListJointsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Joints) > 0 {
		for _, e := range m.Joints {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetJointRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetJointResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Joint != nil {
		l = m.Joint.Size()
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJointRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		l = 0
		for _, e := range m.Jobs {
			l += sovOverload(uint64(e))
		}
		n += 1 + sovOverload(uint64(l)) + l
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJointResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovOverload(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TankSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tank)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Conf)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if len(m.Failures) > 0 {
		for _, s := range m.Failures {
			l = len(s)
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	l = len(m.Stage)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	l = len(m.ExternalId)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.OverloadId != 0 {
		n += 1 + sovOverload(uint64(m.OverloadId))
	}
	l = len(m.ExternalJoint)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.OverloadJoint != 0 {
		n += 1 + sovOverload(uint64(m.OverloadJoint))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterValidateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterValidateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterPrepareRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterPrepareResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterRunRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterRunResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterStopRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterStopResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterPollRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterPollResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterTankSessionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tank)
	if l > 0 {
		n += 1 + l + sovOverload(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirestarterTankSessionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovOverload(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovOverload(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOverload(x uint64) (n int) {
	return sovOverload(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStart", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestStart = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStop", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestStop = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegressionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegressionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tank", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tank = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentDetails", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvironmentDetails = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutostopTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AutostopTime = float64(math.Float64frombits(v))
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutostopMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutostopMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imbalance", wireType)
			}
			m.Imbalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Imbalance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collections = append(m.Collections, &Collection{})
			if err := m.Collections[len(m.Collections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Collection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Collection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Collection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Project = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestJobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestJobs = append(m.LatestJobs, &Job{})
			if err := m.LatestJobs[len(m.LatestJobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStart", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestStart = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStop", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestStop = float64(math.Float64frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegressionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegressionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tank", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tank = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentDetails", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvironmentDetails = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collections = append(m.Collections, &Collection{})
			if err := m.Collections[len(m.Collections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastJobsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastJobsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastJobsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Page = append(m.Page, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Limit = append(m.Limit, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = append(m.Author, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = append(m.Status, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = append(m.Description, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastJobsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastJobsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastJobsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, &Job{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetJobParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetJobParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetJobParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetJobParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetJobParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetJobParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authors", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authors = append(m.Authors, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statuses = append(m.Statuses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Targets = append(m.Targets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStart", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestStart = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStop", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TestStop = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegressionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegressionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tank", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tank = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvironmentDetails", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvironmentDetails = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutostopTime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AutostopTime = float64(math.Float64frombits(v))
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutostopMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AutostopMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imbalance", wireType)
			}
			m.Imbalance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Imbalance |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOverload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Collections = append(m.Collections, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOverload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOverload
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Collections) == 0 {
					m.Collections = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOverload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Collections = append(m.Collections, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Collections", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobAggregate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobAggregate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobAggregate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q50", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q50 = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q75", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q75 = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q80", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q80 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q85", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q85 = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q90", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q90 = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q95", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q95 = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q98", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q98 = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q99", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q99 = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q100", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q100 = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Avg = float32(math.Float32frombits(v))
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OkCount", wireType)
			}
			m.OkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OkCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCount", wireType)
			}
			m.ErrCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRecv", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetRecv = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSend", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetSend = float32(math.Float32frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAggregatesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAggregatesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAggregatesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q50", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q50 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q75", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q75 = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q80", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q80 = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q85", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q85 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q90", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q90 = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q95", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q95 = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q98", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q98 = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q99", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q99 = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q100", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Q100 = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avg", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Avg = float32(math.Float32frombits(v))
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OkCount", wireType)
			}
			m.OkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OkCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCount", wireType)
			}
			m.ErrCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRecv", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetRecv = float32(math.Float32frombits(v))
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSend", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NetSend = float32(math.Float32frombits(v))
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			m.JobId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAggregatesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAggregatesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAggregatesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAggregatesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAggregatesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAggregatesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestId", wireType)
			}
			m.TestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAggregatesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAggregatesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAggregatesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregates = append(m.Aggregates, &JobAggregate{})
			if err := m.Aggregates[len(m.Aggregates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCollectionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCollectionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCollectionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Page = append(m.Page, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Limit = append(m.Limit, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOverload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CollectionId = append(m.CollectionId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOverload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOverload
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CollectionId) == 0 {
					m.CollectionId = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOverload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CollectionId = append(m.CollectionId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionId", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Project = append(m.Project, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ref", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ref = append(m.Ref, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCollectionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCollectionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCollectionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Collections = append(m.Collections, &Collection{})
			if err := m.Collections[len(m.Collections)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCollectionParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCollectionParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCollectionParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCollectionParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCollectionParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCollectionParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Envs = append(m.Envs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projects = append(m.Projects, &Project{})
			if err := m.Projects[len(m.Projects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Project) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Project: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Project: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Project = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ammo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ammo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ammo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Etag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUsed", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.LastUsed = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadAmmoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadAmmoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadAmmoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadAmmoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadAmmoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadAmmoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAmmoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAmmoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAmmoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAmmoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAmmoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAmmoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ammo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ammo = append(m.Ammo, &Ammo{})
			if err := m.Ammo[len(m.Ammo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAmmoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAmmoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAmmoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAmmoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAmmoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAmmoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Artifact) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Artifact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Artifact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Etag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastModified = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadArtifactRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadArtifactRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadArtifactRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Job = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadArtifactResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadArtifactResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadArtifactResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListArtifactsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListArtifactsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListArtifactsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListArtifactsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListArtifactsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListArtifactsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifacts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artifacts = append(m.Artifacts, &Artifact{})
			if err := m.Artifacts[len(m.Artifacts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Joint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Joint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Joint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, &Job{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJointsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJointsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJointsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJointsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJointsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJointsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Joints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Joints = append(m.Joints, &Joint{})
			if err := m.Joints[len(m.Joints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetJointRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetJointRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetJointRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetJointResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetJointResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetJointResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Joint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Joint == nil {
				m.Joint = &Joint{}
			}
			if err := m.Joint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJointRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJointRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJointRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOverload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Jobs = append(m.Jobs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowOverload
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthOverload
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Jobs) == 0 {
					m.Jobs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowOverload
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Jobs = append(m.Jobs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJointResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJointResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJointResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TankSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TankSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TankSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tank", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tank = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Failures = append(m.Failures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverloadId", wireType)
			}
			m.OverloadId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverloadId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalJoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalJoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverloadJoint", wireType)
			}
			m.OverloadJoint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverloadJoint |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterValidateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterValidateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterValidateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterValidateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterValidateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterValidateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterPrepareRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterPrepareRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterPrepareRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterPrepareResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterPrepareResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterPrepareResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterRunRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterRunRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterRunRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterRunResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterRunResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterRunResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterStopRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterStopRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterStopRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterStopResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterStopResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterStopResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterPollRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterPollRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterPollRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterPollResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterPollResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterPollResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterTankSessionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterTankSessionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterTankSessionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tank", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tank = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirestarterTankSessionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirestarterTankSessionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirestarterTankSessionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOverload
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &TankSession{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOverload(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOverload
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOverload(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOverload
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOverload
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOverload
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOverload
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOverload(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOverload = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOverload   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("overload.proto", fileDescriptor_overload_74309234e9e00b12) }

var fileDescriptor_overload_74309234e9e00b12 = []byte{
	// 2437 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x59, 0x4f, 0x73, 0x23, 0x47,
	0x15, 0x67, 0xf4, 0xc7, 0x96, 0x9e, 0x64, 0x5b, 0x6a, 0xff, 0x1b, 0x8f, 0x1d, 0xc7, 0x74, 0x12,
	0x30, 0x5b, 0xb5, 0x2d, 0xb3, 0x64, 0xc9, 0x2e, 0x7f, 0xaa, 0xd8, 0xf5, 0xfe, 0x29, 0x3b, 0x09,
	0x18, 0x6d, 0x02, 0xa7, 0x44, 0x35, 0x92, 0xda, 0xce, 0xd8, 0xd2, 0x8c, 0x76, 0x66, 0xe4, 0x62,
	0xd9, 0xda, 0x2a, 0xe0, 0x0b, 0xe4, 0x00, 0x07, 0xbe, 0x00, 0x9f, 0x01, 0xce, 0x9c, 0x38, 0x42,
	0x71, 0xcb, 0x89, 0x5a, 0xb8, 0xf1, 0x25, 0xa8, 0x7e, 0xdd, 0x3d, 0xd3, 0x33, 0x23, 0x79, 0xd7,
	0x09, 0x17, 0xaa, 0xb8, 0x75, 0xbf, 0xd7, 0xf3, 0xba, 0xfb, 0xfd, 0x5e, 0xbf, 0xfe, 0xbd, 0x1e,
	0x58, 0x0e, 0x2e, 0x79, 0x38, 0x0a, 0xdc, 0x21, 0x9b, 0x84, 0x41, 0x1c, 0x38, 0x3b, 0x67, 0x41,
	0x70, 0x36, 0xe2, 0x1d, 0x77, 0xe2, 0x75, 0x5c, 0xdf, 0x0f, 0x62, 0x37, 0xf6, 0x02, 0x3f, 0x92,
	0x5a, 0xfa, 0x45, 0x19, 0xca, 0xc7, 0x41, 0x9f, 0x2c, 0x43, 0xc9, 0x1b, 0xda, 0xd6, 0x9e, 0xb5,
	0x5f, 0xed, 0x96, 0xbc, 0x21, 0x79, 0x03, 0x20, 0xe6, 0x51, 0xdc, 0x8b, 0x62, 0x37, 0x8c, 0xed,
	0xd2, 0x9e, 0xb5, 0x6f, 0x75, 0xeb, 0x42, 0xf2, 0x44, 0x08, 0xc8, 0x36, 0xd4, 0x95, 0x3a, 0x98,
	0xd8, 0x65, 0xd4, 0xd6, 0xa4, 0x36, 0x98, 0x90, 0x0d, 0x58, 0x18, 0x04, 0xfe, 0xa9, 0x77, 0x66,
	0x57, 0xf6, 0xac, 0xfd, 0x7a, 0x57, 0xf5, 0x84, 0xdc, 0x9d, 0xc6, 0x9f, 0x05, 0xa1, 0x5d, 0x95,
	0x72, 0xd9, 0x23, 0x6f, 0xc1, 0x52, 0xc8, 0xcf, 0x42, 0x1e, 0x45, 0x5e, 0xe0, 0xf7, 0xbc, 0xa1,
	0xbd, 0x80, 0xea, 0x66, 0x2a, 0x3c, 0x1a, 0x92, 0x3d, 0x68, 0x0c, 0x79, 0x34, 0x08, 0xbd, 0x89,
	0x58, 0xbe, 0xbd, 0x88, 0x43, 0x4c, 0x11, 0x21, 0x50, 0x89, 0x5d, 0xff, 0xc2, 0xae, 0xa1, 0x0a,
	0xdb, 0x62, 0xca, 0xd8, 0x0d, 0xcf, 0x78, 0x6c, 0xd7, 0xe5, 0x94, 0xb2, 0x47, 0x3a, 0xb0, 0xca,
	0xfd, 0x4b, 0x2f, 0x0c, 0xfc, 0x31, 0xf7, 0xe3, 0xde, 0x90, 0xc7, 0xae, 0x37, 0x8a, 0x6c, 0xc0,
	0x41, 0xc4, 0x50, 0x3d, 0x90, 0x1a, 0x61, 0x28, 0x8a, 0xdd, 0x78, 0x1a, 0xd9, 0x0d, 0x69, 0x48,
	0xf6, 0xc4, 0xda, 0xdd, 0x69, 0x1c, 0x08, 0x3f, 0xf4, 0x62, 0x6f, 0xcc, 0xed, 0x26, 0x3a, 0xa3,
	0xa9, 0x85, 0x1f, 0x79, 0x63, 0x4e, 0xbe, 0x05, 0xad, 0x64, 0xd0, 0x98, 0x47, 0x91, 0x7b, 0xc6,
	0xed, 0x25, 0x34, 0xb3, 0xa2, 0xe5, 0x1f, 0x4a, 0x31, 0xd9, 0x81, 0xba, 0x37, 0xee, 0xbb, 0x23,
	0xd7, 0x1f, 0x70, 0x7b, 0x19, 0xe1, 0x48, 0x05, 0xe4, 0x26, 0x34, 0x06, 0xc1, 0x68, 0xc4, 0x07,
	0x08, 0xa1, 0xbd, 0xb2, 0x57, 0xde, 0x6f, 0xdc, 0x6a, 0xb0, 0xc3, 0x44, 0xd6, 0x35, 0xf5, 0xf4,
	0x0b, 0x0b, 0x20, 0xd5, 0x15, 0x30, 0x6e, 0x41, 0x99, 0xfb, 0x97, 0x08, 0x6e, 0xbd, 0x2b, 0x9a,
	0xc4, 0x86, 0xc5, 0x49, 0x18, 0x9c, 0xf3, 0x41, 0x8c, 0xa0, 0xd6, 0xbb, 0xba, 0x2b, 0x34, 0x11,
	0x0f, 0x2f, 0xbd, 0x01, 0x57, 0xa0, 0xea, 0xae, 0xb0, 0x12, 0xf2, 0x53, 0x05, 0xa9, 0x68, 0x0a,
	0x20, 0x7c, 0x77, 0xcc, 0x15, 0x8c, 0xd8, 0x36, 0xb0, 0x5f, 0xcc, 0x60, 0x2f, 0x40, 0x7b, 0x36,
	0xe1, 0x09, 0x68, 0xcf, 0x26, 0x9c, 0xbc, 0x0d, 0x30, 0x72, 0x45, 0x34, 0x1d, 0x07, 0xfd, 0xc8,
	0xae, 0xe3, 0x26, 0x2b, 0xec, 0x38, 0xe8, 0x77, 0x0d, 0x39, 0xfd, 0x5b, 0x09, 0x5a, 0x87, 0x21,
	0x77, 0x63, 0x2e, 0x34, 0xfc, 0xe9, 0x94, 0x47, 0x71, 0x2e, 0x6c, 0xad, 0x2b, 0xc3, 0xb6, 0x34,
	0x37, 0x6c, 0xcb, 0x73, 0xc2, 0xb6, 0x72, 0x75, 0xd8, 0x56, 0x5f, 0x1d, 0xb6, 0x0b, 0xf3, 0xc3,
	0x76, 0x71, 0x66, 0xd8, 0xd6, 0x5e, 0x27, 0x6c, 0xeb, 0x73, 0xc3, 0x36, 0x17, 0x30, 0xf0, 0x8a,
	0x80, 0x79, 0x0b, 0xda, 0x86, 0x4b, 0xa3, 0x49, 0xe0, 0x47, 0x3c, 0x1f, 0x36, 0x74, 0x07, 0xc0,
	0xf0, 0x78, 0x5e, 0xfb, 0x0e, 0x34, 0xcc, 0x8f, 0x37, 0xa0, 0x7c, 0x1e, 0xf4, 0x51, 0xaf, 0x41,
	0x14, 0x02, 0xfa, 0x07, 0x0b, 0x56, 0x3e, 0x70, 0x25, 0x94, 0xda, 0x14, 0x81, 0xca, 0x44, 0x1c,
	0x0d, 0x6b, 0xaf, 0x2c, 0x3c, 0x21, 0xda, 0x64, 0x0d, 0xaa, 0x23, 0x6f, 0xec, 0x89, 0x14, 0x24,
	0x84, 0xb2, 0x63, 0x40, 0x52, 0x46, 0xb1, 0x86, 0x24, 0x3d, 0xa5, 0x15, 0x29, 0x57, 0xa7, 0x34,
	0xf5, 0x67, 0x55, 0xca, 0x95, 0x3f, 0x0b, 0xe8, 0x94, 0x73, 0xe8, 0xd0, 0xfb, 0xd0, 0x4a, 0x97,
	0xa9, 0xf6, 0x64, 0x43, 0xe5, 0x5c, 0x44, 0xa6, 0x65, 0x44, 0x26, 0x4a, 0xc4, 0x6a, 0x07, 0xc1,
	0xd4, 0x97, 0x09, 0xb3, 0xda, 0x95, 0x1d, 0xba, 0x0e, 0xab, 0x8f, 0xb9, 0x30, 0x71, 0xe2, 0x86,
	0xee, 0x58, 0x6f, 0x97, 0x9e, 0xc2, 0x5a, 0x56, 0x9c, 0x98, 0x5f, 0x94, 0xdb, 0x89, 0x94, 0x27,
	0x74, 0x97, 0x38, 0x50, 0x93, 0x1b, 0xe2, 0x91, 0xf2, 0x47, 0xd2, 0x17, 0x5f, 0xc9, 0x4d, 0x45,
	0xca, 0x27, 0xba, 0x2b, 0x52, 0x7c, 0xeb, 0xe3, 0xc9, 0x30, 0x7b, 0x50, 0xfe, 0x9f, 0xef, 0xff,
	0x17, 0xf2, 0xfd, 0x5e, 0x31, 0xdf, 0x57, 0xb3, 0x27, 0x76, 0x15, 0xda, 0x06, 0xb6, 0x32, 0x82,
	0x28, 0x85, 0xd6, 0x03, 0x3e, 0xe2, 0x57, 0x01, 0x2e, 0x3e, 0x34, 0xc6, 0xa8, 0x0f, 0x7f, 0x57,
	0x86, 0xe6, 0x71, 0xd0, 0xbf, 0x77, 0x76, 0x16, 0xf2, 0x33, 0x37, 0x2e, 0x9c, 0x7d, 0x3c, 0x8e,
	0x6e, 0x9f, 0x8f, 0xd4, 0xa5, 0x21, 0x3b, 0xe2, 0x0a, 0x78, 0x7a, 0xfb, 0x00, 0xe3, 0xa2, 0xd4,
	0x15, 0x4d, 0x94, 0xbc, 0x77, 0x1b, 0xe3, 0x41, 0x48, 0xde, 0xbb, 0x8d, 0x92, 0x3b, 0x07, 0x18,
	0x09, 0x42, 0x72, 0x47, 0x8e, 0xb9, 0x73, 0x1b, 0xc1, 0x47, 0x89, 0x1c, 0x73, 0xf7, 0x00, 0xb1,
	0x16, 0x92, 0xbb, 0x72, 0xcc, 0xdd, 0xdb, 0x08, 0x31, 0x4a, 0xd4, 0x98, 0x3b, 0x08, 0x2f, 0x4a,
	0xee, 0x48, 0xc9, 0x5d, 0xc4, 0x12, 0x25, 0x77, 0x45, 0x64, 0x3c, 0xfd, 0xf6, 0xc1, 0x01, 0x42,
	0x57, 0xea, 0x62, 0x5b, 0x8c, 0x72, 0x2f, 0xcf, 0x10, 0xae, 0x52, 0x57, 0x34, 0x65, 0x18, 0xca,
	0x8d, 0xf7, 0x06, 0xc1, 0x50, 0x43, 0xd4, 0xd4, 0xc2, 0xc3, 0x60, 0xc8, 0xc9, 0x16, 0xd4, 0x82,
	0x8b, 0x9e, 0x3c, 0xd4, 0x02, 0x9e, 0x72, 0x77, 0x31, 0xb8, 0x38, 0x14, 0x5d, 0x71, 0x26, 0x78,
	0x18, 0x2a, 0xdd, 0x0a, 0xea, 0x6a, 0x3c, 0x0c, 0xa5, 0x72, 0x0b, 0x6a, 0x3e, 0x8f, 0x7b, 0x21,
	0x1f, 0x5c, 0xda, 0x2d, 0x9c, 0x73, 0xd1, 0xe7, 0x71, 0x97, 0x0f, 0x2e, 0xb5, 0x2a, 0xe2, 0xfe,
	0xd0, 0x6e, 0x27, 0xaa, 0x27, 0xdc, 0x1f, 0x92, 0x75, 0x58, 0x38, 0x0f, 0xfa, 0xe2, 0x48, 0x10,
	0x99, 0x40, 0xce, 0x83, 0xfe, 0xd1, 0x90, 0x7e, 0x5e, 0x86, 0x4d, 0x99, 0x97, 0x13, 0x64, 0x92,
	0xa4, 0x99, 0x20, 0x62, 0xcd, 0x40, 0xa4, 0x54, 0x40, 0xa4, 0x5c, 0x40, 0xa4, 0x52, 0x40, 0xa4,
	0x5a, 0x40, 0x64, 0xa1, 0x80, 0xc8, 0x62, 0x01, 0x91, 0x5a, 0x01, 0x91, 0x7a, 0x11, 0x11, 0x28,
	0x22, 0xd2, 0xb8, 0x02, 0x91, 0xe6, 0x2b, 0x10, 0x59, 0xba, 0x02, 0x91, 0xe5, 0x2b, 0x10, 0x59,
	0x99, 0x8f, 0x48, 0x6b, 0x1e, 0x22, 0x6d, 0x13, 0x91, 0x1b, 0x60, 0x17, 0x01, 0x99, 0x73, 0x5f,
	0x76, 0x30, 0xcf, 0x17, 0x91, 0xdb, 0x84, 0x45, 0xcc, 0xa9, 0xc9, 0xe0, 0x05, 0xd1, 0x3d, 0x1a,
	0xd2, 0x47, 0xb0, 0x9e, 0xfb, 0x40, 0x59, 0xbe, 0x09, 0xe0, 0x26, 0x52, 0x75, 0xfd, 0x2c, 0x31,
	0xf3, 0xc0, 0x76, 0x8d, 0x01, 0xf4, 0x4f, 0x16, 0x1a, 0x4a, 0x2f, 0xfb, 0x2f, 0x71, 0xd3, 0xbe,
	0x05, 0x4b, 0x69, 0xba, 0x11, 0x4b, 0x2d, 0x63, 0x0e, 0x6a, 0xa6, 0xc2, 0xa3, 0x84, 0x48, 0xca,
	0x3b, 0x37, 0x4f, 0x24, 0xe5, 0x8d, 0x9b, 0x10, 0x49, 0x45, 0x17, 0xe5, 0x55, 0x9b, 0xa1, 0x8b,
	0x8b, 0x72, 0x31, 0xa2, 0x4d, 0x3f, 0x81, 0x8d, 0xfc, 0xca, 0x13, 0x1f, 0x64, 0x52, 0xa2, 0x75,
	0x35, 0xa3, 0x99, 0x73, 0x23, 0xef, 0x80, 0x93, 0x31, 0x9f, 0xbd, 0x98, 0x7f, 0x6d, 0xc1, 0xf6,
	0x4c, 0xb5, 0x5a, 0x02, 0x81, 0x0a, 0xf7, 0x2f, 0xf5, 0xed, 0x8c, 0x6d, 0xf2, 0x36, 0xd4, 0xd4,
	0x0e, 0xe5, 0xd5, 0xdc, 0xb8, 0x55, 0x63, 0x27, 0x52, 0xd0, 0x4d, 0x34, 0xe2, 0xcb, 0x90, 0x9f,
	0xea, 0x1b, 0x1a, 0xdb, 0x62, 0x85, 0x62, 0xcb, 0x9a, 0xb2, 0xc8, 0x0e, 0xfd, 0x21, 0x2c, 0x9e,
	0xa4, 0xd4, 0x5b, 0xfb, 0xd2, 0x9a, 0x4b, 0xca, 0x4b, 0x19, 0x52, 0x4e, 0xff, 0x6c, 0x41, 0xe5,
	0xde, 0x78, 0x1c, 0xe0, 0x5a, 0x63, 0xf7, 0x4c, 0x7d, 0x89, 0x6d, 0x01, 0xc1, 0x05, 0x7f, 0xa6,
	0x79, 0xff, 0x05, 0x7f, 0x26, 0x50, 0x1e, 0xb9, 0x51, 0xdc, 0x1b, 0x07, 0x43, 0xef, 0xd4, 0xe3,
	0x43, 0xc5, 0x80, 0x9b, 0x42, 0xf8, 0xa1, 0x92, 0x89, 0xd3, 0x85, 0x83, 0xa6, 0x11, 0x1f, 0x62,
	0xd6, 0xb0, 0xba, 0x35, 0x21, 0xf8, 0x38, 0xe2, 0xc3, 0xb9, 0x77, 0x3d, 0x81, 0x4a, 0xe4, 0xfd,
	0x52, 0xd6, 0x02, 0xe5, 0x2e, 0xb6, 0x65, 0xf4, 0xc5, 0x9f, 0x69, 0xc6, 0x2b, 0xda, 0xb3, 0xea,
	0x00, 0xfa, 0x7d, 0x71, 0xb7, 0x89, 0x4a, 0x56, 0xec, 0xc4, 0x08, 0x5d, 0x8c, 0x16, 0xcb, 0x28,
	0x2e, 0x08, 0x54, 0x4e, 0xbd, 0x91, 0x76, 0x02, 0xb6, 0xe9, 0x37, 0x80, 0x98, 0x1f, 0x2b, 0xe8,
	0x5a, 0x50, 0x9e, 0x86, 0x3a, 0x57, 0x8a, 0x26, 0x6d, 0xc3, 0xca, 0x07, 0x5e, 0x14, 0x1b, 0x53,
	0xd0, 0x9b, 0xd0, 0x4a, 0x45, 0xea, 0xc3, 0x2d, 0xa8, 0xb8, 0xe3, 0x71, 0xa0, 0xe2, 0xad, 0xca,
	0x50, 0x89, 0x22, 0xfa, 0x8e, 0xbe, 0x49, 0xcd, 0x65, 0x2a, 0x1f, 0x5b, 0x89, 0x8f, 0xe9, 0x1a,
	0x10, 0x73, 0x98, 0xba, 0x71, 0x3f, 0xb7, 0xa0, 0x76, 0x2f, 0x8c, 0xbd, 0x53, 0x77, 0x10, 0xff,
	0x37, 0xc1, 0x7a, 0x5d, 0xbf, 0xb7, 0x24, 0x3f, 0xaf, 0xe3, 0xe9, 0x40, 0x66, 0xfe, 0x53, 0x58,
	0x57, 0x8e, 0x53, 0xcb, 0x32, 0xb6, 0xa4, 0xa9, 0x7c, 0x1d, 0x87, 0x26, 0x58, 0x94, 0x66, 0x60,
	0x51, 0x36, 0xb0, 0xb8, 0x01, 0x1b, 0x79, 0x93, 0x73, 0xf1, 0xd8, 0x87, 0x35, 0x74, 0xbe, 0x1a,
	0x19, 0xcd, 0x98, 0x5d, 0x2d, 0xf4, 0x47, 0xb0, 0x9e, 0x1b, 0xa9, 0x8c, 0x7e, 0x13, 0xea, 0xae,
	0x16, 0x2a, 0xc0, 0xea, 0x2c, 0x99, 0x3a, 0xd5, 0xd1, 0x87, 0x50, 0x3d, 0x0e, 0x3c, 0xbf, 0xc8,
	0x86, 0x35, 0xc3, 0x2f, 0x15, 0x18, 0xbe, 0xde, 0x72, 0x39, 0xdd, 0xb2, 0xa0, 0x52, 0x62, 0x21,
	0x68, 0x2a, 0x49, 0x22, 0xef, 0x02, 0x31, 0x85, 0x6a, 0x69, 0xbb, 0xe2, 0x3a, 0x11, 0x12, 0xb5,
	0xae, 0x05, 0x86, 0x03, 0xba, 0x4a, 0x4a, 0xbf, 0x0e, 0x2b, 0x58, 0x13, 0x08, 0xd9, 0x1c, 0xe2,
	0x76, 0x00, 0xad, 0x74, 0x88, 0x32, 0xbb, 0x03, 0x55, 0x34, 0xa0, 0xea, 0x2c, 0x6d, 0x55, 0x0a,
	0xe9, 0x0f, 0x80, 0xe8, 0xaa, 0xce, 0xb0, 0x4b, 0x8c, 0x2a, 0xa6, 0x9a, 0xdb, 0x9d, 0x01, 0x28,
	0x7d, 0x07, 0x56, 0x33, 0x5f, 0xcf, 0xb9, 0xe5, 0xfe, 0x58, 0x82, 0xc6, 0x47, 0xae, 0x7f, 0xf1,
	0x44, 0x32, 0xf8, 0x84, 0x9d, 0x5b, 0x06, 0x3b, 0x27, 0x50, 0x11, 0xa5, 0x81, 0x36, 0x2f, 0xda,
	0xb3, 0x1c, 0x2a, 0xea, 0x9c, 0x53, 0xd7, 0x1b, 0x4d, 0xc3, 0x24, 0x2b, 0x26, 0x7d, 0x91, 0x2e,
	0xa3, 0x58, 0xdc, 0x5d, 0x32, 0xcf, 0xc8, 0x8e, 0x41, 0xd7, 0x17, 0x32, 0x74, 0x7d, 0x17, 0x80,
	0xff, 0x22, 0xe6, 0xa1, 0xef, 0x8e, 0x8e, 0x86, 0x2a, 0xf0, 0x0d, 0x89, 0xd0, 0xeb, 0xe7, 0xb2,
	0xa3, 0x21, 0x26, 0x9f, 0x6a, 0xd7, 0x90, 0x90, 0xb7, 0x61, 0x49, 0x8f, 0xc6, 0xed, 0xab, 0xb2,
	0x22, 0x2b, 0x14, 0xa3, 0xf4, 0x37, 0x72, 0x14, 0xa0, 0xa1, 0xac, 0xd0, 0x48, 0x91, 0x0d, 0x33,
	0x45, 0xd2, 0x47, 0xe0, 0x3c, 0xf2, 0x42, 0x8e, 0x95, 0x17, 0x0f, 0x7f, 0xe6, 0x8e, 0x3c, 0xc1,
	0xe7, 0x35, 0x4c, 0xfb, 0x50, 0x8b, 0xa4, 0x4b, 0x75, 0xcc, 0x34, 0x99, 0xe1, 0xe7, 0x6e, 0xa2,
	0xa5, 0x8f, 0x61, 0x7b, 0xa6, 0x1d, 0x05, 0xd8, 0xeb, 0x1b, 0x7a, 0x08, 0x5b, 0x86, 0xa1, 0x93,
	0x90, 0x4f, 0xdc, 0xf0, 0x4b, 0xac, 0x27, 0xbb, 0xaf, 0xc4, 0xcc, 0xb5, 0x97, 0x73, 0x0f, 0xd6,
	0x0d, 0x3b, 0xdd, 0xa9, 0x7f, 0xfd, 0xa5, 0xdc, 0x87, 0x8d, 0xbc, 0x89, 0x6b, 0x2f, 0x23, 0x6b,
	0x43, 0x14, 0xbe, 0xd7, 0x5f, 0xc7, 0x21, 0x6c, 0x16, 0x6c, 0x7c, 0xc5, 0x85, 0x9c, 0x04, 0xa3,
	0xd1, 0x57, 0x5d, 0x88, 0xb4, 0x71, 0xed, 0x85, 0xbc, 0x0b, 0xbb, 0x86, 0x11, 0x63, 0x8c, 0xc9,
	0x33, 0xf3, 0x49, 0x80, 0xbe, 0x0f, 0x6f, 0xce, 0xfd, 0xea, 0xba, 0x4b, 0xb8, 0xf5, 0xef, 0x16,
	0xac, 0xfc, 0x44, 0x9d, 0xb2, 0x27, 0xea, 0x41, 0xf2, 0x18, 0xea, 0xc9, 0x23, 0x16, 0x69, 0xb3,
	0xfc, 0x1b, 0xa1, 0x43, 0x58, 0xe1, 0x8d, 0x8b, 0x6e, 0xfc, 0xe6, 0xef, 0xff, 0xfa, 0x6d, 0xa9,
	0x45, 0x1b, 0x9d, 0x01, 0xea, 0x7a, 0xe7, 0x41, 0xff, 0x7b, 0xd6, 0x0d, 0xf2, 0x5d, 0x58, 0x90,
	0x6f, 0x34, 0xa4, 0xc1, 0x0c, 0x13, 0x4d, 0x66, 0x7e, 0xdc, 0xc6, 0x8f, 0x1b, 0xa4, 0xde, 0x39,
	0x0f, 0xfa, 0x9d, 0xe7, 0xde, 0xf0, 0x05, 0x79, 0x08, 0x8d, 0xc7, 0x3c, 0xd6, 0x2f, 0x47, 0xa4,
	0xc5, 0x72, 0x6f, 0x5d, 0x4e, 0x9b, 0xe5, 0x9f, 0x95, 0x0c, 0x33, 0xe2, 0x26, 0xc7, 0x7c, 0x7c,
	0x02, 0x4d, 0xf3, 0x89, 0x88, 0xac, 0xb1, 0x19, 0x0f, 0x49, 0xce, 0x3a, 0x9b, 0xf5, 0x8e, 0x44,
	0x57, 0xd1, 0xde, 0x12, 0x69, 0x88, 0x65, 0xf5, 0x26, 0xd2, 0xc2, 0x31, 0xd4, 0x93, 0xf7, 0x02,
	0xd2, 0x66, 0xf9, 0x77, 0x21, 0x87, 0xb0, 0xe2, 0x73, 0x42, 0xea, 0x9c, 0x29, 0xea, 0xb4, 0x73,
	0x8e, 0xa1, 0x9e, 0x3c, 0x21, 0x90, 0x36, 0xcb, 0x3f, 0x39, 0x38, 0x84, 0x15, 0x5f, 0x18, 0x52,
	0x5b, 0x43, 0xd4, 0x69, 0x5b, 0xa7, 0xfa, 0x31, 0x37, 0x2d, 0x7b, 0x88, 0xcd, 0xe6, 0x14, 0xbd,
	0xce, 0x16, 0x9b, 0x57, 0x7d, 0xd1, 0x37, 0x70, 0x82, 0x4d, 0x4a, 0x3a, 0x53, 0xa4, 0x1c, 0xbd,
	0xb4, 0x20, 0x12, 0xf3, 0x7c, 0x02, 0x4b, 0x99, 0xda, 0x8a, 0xa0, 0xf3, 0x8a, 0x33, 0x6c, 0xb0,
	0x99, 0x25, 0x98, 0x36, 0x4f, 0xd6, 0x3b, 0xa9, 0xdd, 0xce, 0x73, 0x55, 0xc7, 0xbd, 0x20, 0x3f,
	0x87, 0xe5, 0x6c, 0xdd, 0x42, 0xd0, 0x50, 0xb1, 0x04, 0x73, 0x36, 0xd9, 0xec, 0x02, 0x87, 0xae,
	0xe1, 0x0c, 0xcb, 0xa4, 0xd9, 0x31, 0xeb, 0x98, 0x11, 0xbe, 0x21, 0xe6, 0x4b, 0x12, 0xb2, 0xcd,
	0xe6, 0xd7, 0x31, 0xce, 0x0e, 0xbb, 0xa2, 0x8a, 0xa1, 0x0e, 0xce, 0xb3, 0x46, 0x88, 0x31, 0x8f,
	0x8e, 0x92, 0x1f, 0x03, 0xa4, 0xe4, 0x99, 0x88, 0x98, 0xc8, 0xd1, 0x70, 0x67, 0x95, 0x15, 0xd9,
	0x35, 0xdd, 0x44, 0x93, 0x6d, 0xda, 0x4c, 0x7c, 0x3f, 0x1e, 0x07, 0xc2, 0xeb, 0x87, 0x50, 0xd3,
	0x8c, 0x5a, 0x9c, 0x85, 0x2c, 0xdf, 0x16, 0x67, 0x21, 0x47, 0xb7, 0x29, 0x41, 0x4b, 0x4d, 0x02,
	0x9d, 0x91, 0x17, 0xc5, 0x68, 0x87, 0xbc, 0x0f, 0x90, 0x12, 0x68, 0xa2, 0x83, 0x2b, 0xbb, 0xa8,
	0x19, 0x0c, 0x3b, 0xf5, 0xa7, 0x8a, 0x38, 0x34, 0xf6, 0x29, 0x2c, 0x67, 0x29, 0x29, 0xd9, 0x60,
	0x33, 0x69, 0xaf, 0xb3, 0xc9, 0x66, 0x73, 0x57, 0xba, 0x8d, 0x86, 0xd7, 0x69, 0x2b, 0xd9, 0xad,
	0x1a, 0xa1, 0xe2, 0x2c, 0x43, 0x4e, 0xc9, 0x3a, 0x9b, 0x45, 0x6b, 0x9d, 0x0d, 0x36, 0x93, 0xc3,
	0x1a, 0x71, 0x26, 0x1d, 0xa0, 0x07, 0x74, 0x9e, 0x9f, 0x07, 0xfd, 0x17, 0xc2, 0x17, 0x29, 0xbb,
	0x24, 0x84, 0x15, 0xf8, 0xa7, 0xb3, 0xca, 0x8a, 0xf4, 0xd3, 0xf0, 0x05, 0x5a, 0x95, 0xa4, 0x93,
	0x3c, 0x80, 0x9a, 0x66, 0x94, 0xa4, 0xc5, 0x72, 0xfc, 0xd3, 0x69, 0xb3, 0x3c, 0xdd, 0xcc, 0x64,
	0x16, 0xcf, 0x8f, 0x65, 0xca, 0xeb, 0x42, 0xc3, 0xe0, 0x89, 0x64, 0x95, 0x15, 0x39, 0xa7, 0xb3,
	0xc6, 0x66, 0x50, 0x49, 0x6a, 0xa3, 0x39, 0x42, 0x97, 0xd2, 0xe4, 0xeb, 0xf9, 0xe8, 0xc5, 0x10,
	0x56, 0x67, 0x50, 0x1a, 0xb2, 0xcd, 0xe6, 0x13, 0x26, 0x67, 0x87, 0x5d, 0xc1, 0x82, 0xe8, 0x1e,
	0xce, 0xe5, 0xd0, 0xf5, 0xce, 0x69, 0x3a, 0xaa, 0x73, 0xa9, 0x86, 0x89, 0x39, 0x7d, 0x20, 0x45,
	0xda, 0x42, 0x1c, 0x36, 0x97, 0x12, 0x39, 0xdb, 0x6c, 0x3e, 0xcf, 0xa1, 0x6f, 0xe2, 0x84, 0x5b,
	0x74, 0x2d, 0x33, 0xe1, 0x44, 0x8e, 0x12, 0xf3, 0x7d, 0x0a, 0xcb, 0x59, 0x6e, 0x42, 0x36, 0xd8,
	0x4c, 0xbe, 0xe3, 0x6c, 0xb2, 0xd9, 0x24, 0xc6, 0x88, 0x44, 0x73, 0x8e, 0x70, 0xea, 0x0b, 0xfb,
	0x7d, 0x58, 0xc9, 0x71, 0x0e, 0x92, 0x31, 0x64, 0x30, 0x19, 0xc7, 0x66, 0x73, 0xe8, 0x09, 0xdd,
	0xc1, 0x29, 0x36, 0x68, 0x3b, 0x33, 0x45, 0x14, 0x07, 0x93, 0xe2, 0x1c, 0x82, 0x4e, 0x64, 0xe7,
	0x30, 0x48, 0x4a, 0x76, 0x0e, 0x93, 0x79, 0xcc, 0x99, 0x63, 0x12, 0x8c, 0x46, 0x62, 0x8e, 0x5f,
	0x59, 0x19, 0xce, 0x62, 0x12, 0x07, 0xf2, 0x26, 0xbb, 0x9a, 0x88, 0x38, 0x7b, 0xec, 0x15, 0x9c,
	0x83, 0x52, 0x9c, 0x7c, 0x87, 0x38, 0x99, 0xc9, 0x05, 0x63, 0xe9, 0x69, 0xb6, 0x71, 0xbf, 0xf5,
	0x97, 0x97, 0xbb, 0xd6, 0x5f, 0x5f, 0xee, 0x5a, 0xff, 0x78, 0xb9, 0x6b, 0xfd, 0xfe, 0x9f, 0xbb,
	0x5f, 0xeb, 0x2f, 0xe0, 0x5f, 0xf4, 0xef, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0xad, 0x74, 0x5a,
	0x61, 0x75, 0x1f, 0x00, 0x00,
}
