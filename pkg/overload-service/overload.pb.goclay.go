// Code generated by protoc-gen-goclay. DO NOT EDIT.
// source: overload.proto

/*
Package overload is a self-registering gRPC and JSON+Swagger service definition.

It conforms to the github.com/utrack/clay/v2/transport Service interface.
*/
package overload

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/go-chi/chi"
	"github.com/go-openapi/spec"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"github.com/grpc-ecosystem/grpc-gateway/utilities"
	"github.com/pkg/errors"
	"github.com/utrack/clay/v2/transport"
	"github.com/utrack/clay/v2/transport/httpclient"
	"github.com/utrack/clay/v2/transport/httpruntime"
	"github.com/utrack/clay/v2/transport/httpruntime/httpmw"
	"github.com/utrack/clay/v2/transport/httptransport"
	"github.com/utrack/clay/v2/transport/swagger"
	"google.golang.org/grpc"
)

// Update your shared lib or downgrade generator to v1 if there's an error
var _ = transport.IsVersion2

var _ = ioutil.Discard
var _ chi.Router
var _ runtime.Marshaler
var _ bytes.Buffer
var _ context.Context
var _ fmt.Formatter
var _ strings.Reader
var _ errors.Frame
var _ httpruntime.Marshaler
var _ http.Handler
var _ url.Values
var _ base64.Encoding
var _ httptransport.MarshalerError
var _ utilities.DoubleArray

// OverloadServiceDesc is a descriptor/registrator for the OverloadServiceServer.
type OverloadServiceDesc struct {
	svc  OverloadServiceServer
	opts httptransport.DescOptions
}

// NewOverloadServiceServiceDesc creates new registrator for the OverloadServiceServer.
// It implements httptransport.ConfigurableServiceDesc as well.
func NewOverloadServiceServiceDesc(svc OverloadServiceServer) *OverloadServiceDesc {
	return &OverloadServiceDesc{
		svc: svc,
	}
}

// RegisterGRPC implements service registrator interface.
func (d *OverloadServiceDesc) RegisterGRPC(s *grpc.Server) {
	RegisterOverloadServiceServer(s, d.svc)
}

// Apply applies passed options.
func (d *OverloadServiceDesc) Apply(oo ...transport.DescOption) {
	for _, o := range oo {
		o.Apply(&d.opts)
	}
}

// SwaggerDef returns this file's Swagger definition.
func (d *OverloadServiceDesc) SwaggerDef(options ...swagger.Option) (result []byte) {
	if len(options) > 0 {
		var err error
		var s = &spec.Swagger{}
		if err = s.UnmarshalJSON(_swaggerDef_overload_proto); err != nil {
			panic("Bad swagger definition: " + err.Error())
		}

		for _, o := range d.opts.SwaggerDefaultOpts {
			o(s)
		}
		for _, o := range options {
			o(s)
		}
		if result, err = s.MarshalJSON(); err != nil {
			panic("Failed marshal spec.Swagger definition: " + err.Error())
		}
	} else {
		result = _swaggerDef_overload_proto
	}
	return result
}

// RegisterHTTP registers this service's HTTP handlers/bindings.
func (d *OverloadServiceDesc) RegisterHTTP(mux transport.Router) {
	chiMux, isChi := mux.(chi.Router)

	{
		// Handler for CreateJob, binding: POST /create_job
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_CreateJob_0(r)
			rsp, err := _OverloadService_CreateJob_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_CreateJob_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_CreateJob_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetJob, binding: GET /job/{id}
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_GetJob_0(r)
			rsp, err := _OverloadService_GetJob_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_GetJob_0, h)
		} else {
			panic("query URI params supported only for chi.Router")
		}
	}

	{
		// Handler for GetLastJobs, binding: GET /lastjobs
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_GetLastJobs_0(r)
			rsp, err := _OverloadService_GetLastJobs_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_GetLastJobs_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_GetLastJobs_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetJobParams, binding: GET /job_params
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_GetJobParams_0(r)
			rsp, err := _OverloadService_GetJobParams_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_GetJobParams_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_GetJobParams_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for UpdateJob, binding: POST /update_job
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_UpdateJob_0(r)
			rsp, err := _OverloadService_UpdateJob_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_UpdateJob_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_UpdateJob_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for DeleteJob, binding: POST /delete_job
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_DeleteJob_0(r)
			rsp, err := _OverloadService_DeleteJob_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_DeleteJob_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_DeleteJob_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for CreateAggregates, binding: POST /upload_aggregates
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_CreateAggregates_0(r)
			rsp, err := _OverloadService_CreateAggregates_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_CreateAggregates_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_CreateAggregates_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetAggregates, binding: GET /aggregates/{test_id}
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_GetAggregates_0(r)
			rsp, err := _OverloadService_GetAggregates_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_GetAggregates_0, h)
		} else {
			panic("query URI params supported only for chi.Router")
		}
	}

	{
		// Handler for GetCollections, binding: GET /collections
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_GetCollections_0(r)
			rsp, err := _OverloadService_GetCollections_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_GetCollections_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_GetCollections_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetCollectionParams, binding: GET /collection_params
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_GetCollectionParams_0(r)
			rsp, err := _OverloadService_GetCollectionParams_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_GetCollectionParams_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_GetCollectionParams_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for UploadAmmo, binding: POST /upload_ammo
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_UploadAmmo_0(r)
			rsp, err := _OverloadService_UploadAmmo_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_UploadAmmo_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_UploadAmmo_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for ListAmmo, binding: GET /list_ammo
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_ListAmmo_0(r)
			rsp, err := _OverloadService_ListAmmo_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_ListAmmo_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_ListAmmo_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for DeleteAmmo, binding: GET /delete_ammo
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_DeleteAmmo_0(r)
			rsp, err := _OverloadService_DeleteAmmo_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_DeleteAmmo_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_DeleteAmmo_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for UploadArtifact, binding: POST /upload_artifact
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_UploadArtifact_0(r)
			rsp, err := _OverloadService_UploadArtifact_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_UploadArtifact_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_UploadArtifact_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for ListArtifacts, binding: GET /list_artifacts/{job}
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_ListArtifacts_0(r)
			rsp, err := _OverloadService_ListArtifacts_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_ListArtifacts_0, h)
		} else {
			panic("query URI params supported only for chi.Router")
		}
	}

	{
		// Handler for ListJoints, binding: GET /list_joints
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_ListJoints_0(r)
			rsp, err := _OverloadService_ListJoints_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_ListJoints_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_ListJoints_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetJoint, binding: GET /joint/{id}
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_GetJoint_0(r)
			rsp, err := _OverloadService_GetJoint_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_GetJoint_0, h)
		} else {
			panic("query URI params supported only for chi.Router")
		}
	}

	{
		// Handler for CreateJoint, binding: POST /create_joint
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_CreateJoint_0(r)
			rsp, err := _OverloadService_CreateJoint_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_CreateJoint_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_CreateJoint_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for FirestarterValidate, binding: POST /firestarter/validate
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_FirestarterValidate_0(r)
			rsp, err := _OverloadService_FirestarterValidate_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_FirestarterValidate_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_FirestarterValidate_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for FirestarterPrepare, binding: POST /firestarter/prepare
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_FirestarterPrepare_0(r)
			rsp, err := _OverloadService_FirestarterPrepare_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_FirestarterPrepare_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_FirestarterPrepare_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for FirestarterRun, binding: POST /firestarter/run
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_FirestarterRun_0(r)
			rsp, err := _OverloadService_FirestarterRun_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_FirestarterRun_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_FirestarterRun_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for FirestarterStop, binding: POST /firestarter/stop
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_FirestarterStop_0(r)
			rsp, err := _OverloadService_FirestarterStop_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_FirestarterStop_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_FirestarterStop_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for FirestarterPoll, binding: POST /firestarter/poll
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_FirestarterPoll_0(r)
			rsp, err := _OverloadService_FirestarterPoll_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_OverloadService_FirestarterPoll_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_FirestarterPoll_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for FirestarterTankSessions, binding: GET /firestarter/tank_sessions
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_OverloadService_FirestarterTankSessions_0(r)
			rsp, err := _OverloadService_FirestarterTankSessions_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "returned from handler"))
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("GET", pattern_goclay_OverloadService_FirestarterTankSessions_0, h)
		} else {
			mux.Handle(pattern_goclay_OverloadService_FirestarterTankSessions_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "GET" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

}

type OverloadService_httpClient struct {
	c    *http.Client
	host string
}

// NewOverloadServiceHTTPClient creates new HTTP client for OverloadServiceServer.
// Pass addr in format "http://host[:port]".
func NewOverloadServiceHTTPClient(c *http.Client, addr string) *OverloadService_httpClient {
	if strings.HasSuffix(addr, "/") {
		addr = addr[:len(addr)-1]
	}
	return &OverloadService_httpClient{c: c, host: addr}
}

func (c *OverloadService_httpClient) CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*CreateJobResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_CreateJob_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &CreateJobResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) GetJob(ctx context.Context, in *JobRequest, opts ...grpc.CallOption) (*JobResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_GetJob_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &JobResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) GetLastJobs(ctx context.Context, in *LastJobsRequest, opts ...grpc.CallOption) (*LastJobsResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_GetLastJobs_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &LastJobsResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) GetJobParams(ctx context.Context, in *GetJobParamsRequest, opts ...grpc.CallOption) (*GetJobParamsResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_GetJobParams_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &GetJobParamsResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) UpdateJob(ctx context.Context, in *UpdateJobRequest, opts ...grpc.CallOption) (*UpdateJobResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_UpdateJob_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &UpdateJobResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*DeleteJobResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_DeleteJob_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &DeleteJobResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) CreateAggregates(ctx context.Context, in *CreateAggregatesRequest, opts ...grpc.CallOption) (*CreateAggregatesResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_CreateAggregates_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &CreateAggregatesResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) GetAggregates(ctx context.Context, in *GetAggregatesRequest, opts ...grpc.CallOption) (*GetAggregatesResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_GetAggregates_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &GetAggregatesResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) GetCollections(ctx context.Context, in *GetCollectionsRequest, opts ...grpc.CallOption) (*GetCollectionsResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_GetCollections_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &GetCollectionsResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) GetCollectionParams(ctx context.Context, in *GetCollectionParamsRequest, opts ...grpc.CallOption) (*GetCollectionParamsResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_GetCollectionParams_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &GetCollectionParamsResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) UploadAmmo(ctx context.Context, in *UploadAmmoRequest, opts ...grpc.CallOption) (*UploadAmmoResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_UploadAmmo_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &UploadAmmoResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) ListAmmo(ctx context.Context, in *ListAmmoRequest, opts ...grpc.CallOption) (*ListAmmoResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_ListAmmo_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &ListAmmoResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) DeleteAmmo(ctx context.Context, in *DeleteAmmoRequest, opts ...grpc.CallOption) (*DeleteAmmoResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_DeleteAmmo_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &DeleteAmmoResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) UploadArtifact(ctx context.Context, in *UploadArtifactRequest, opts ...grpc.CallOption) (*UploadArtifactResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_UploadArtifact_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &UploadArtifactResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_ListArtifacts_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &ListArtifactsResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) ListJoints(ctx context.Context, in *ListJointsRequest, opts ...grpc.CallOption) (*ListJointsResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_ListJoints_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &ListJointsResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) GetJoint(ctx context.Context, in *GetJointRequest, opts ...grpc.CallOption) (*GetJointResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_GetJoint_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &GetJointResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) CreateJoint(ctx context.Context, in *CreateJointRequest, opts ...grpc.CallOption) (*CreateJointResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_CreateJoint_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &CreateJointResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) FirestarterValidate(ctx context.Context, in *FirestarterValidateRequest, opts ...grpc.CallOption) (*FirestarterValidateResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_FirestarterValidate_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &FirestarterValidateResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) FirestarterPrepare(ctx context.Context, in *FirestarterPrepareRequest, opts ...grpc.CallOption) (*FirestarterPrepareResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_FirestarterPrepare_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &FirestarterPrepareResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) FirestarterRun(ctx context.Context, in *FirestarterRunRequest, opts ...grpc.CallOption) (*FirestarterRunResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_FirestarterRun_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &FirestarterRunResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) FirestarterStop(ctx context.Context, in *FirestarterStopRequest, opts ...grpc.CallOption) (*FirestarterStopResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_FirestarterStop_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &FirestarterStopResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) FirestarterPoll(ctx context.Context, in *FirestarterPollRequest, opts ...grpc.CallOption) (*FirestarterPollResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_FirestarterPoll_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &FirestarterPollResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *OverloadService_httpClient) FirestarterTankSessions(ctx context.Context, in *FirestarterTankSessionsRequest, opts ...grpc.CallOption) (*FirestarterTankSessionsResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_OverloadService_FirestarterTankSessions_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	req, err := http.NewRequest("GET", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := &FirestarterTankSessionsResponse{}
	err = m.Unmarshal(rsp.Body, ret)
	return ret, errors.Wrap(err, "can't unmarshal response")
}

// patterns for OverloadService
var (
	pattern_goclay_OverloadService_CreateJob_0 = "/create_job"

	pattern_goclay_OverloadService_CreateJob_0_builder = func(in *CreateJobRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/create_job"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_CreateJob_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_GetJob_0 = "/job/{id}"

	pattern_goclay_OverloadService_GetJob_0_builder = func(in *JobRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/job/%v", in.Id),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_GetJob_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"id": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_GetLastJobs_0 = "/lastjobs"

	pattern_goclay_OverloadService_GetLastJobs_0_builder = func(in *LastJobsRequest) string {
		values := url.Values{}
		for _, v := range in.Page {
			values.Add("page", fmt.Sprintf("%s", v))
		}
		for _, v := range in.Limit {
			values.Add("limit", fmt.Sprintf("%s", v))
		}
		for _, v := range in.Author {
			values.Add("author", fmt.Sprintf("%s", v))
		}
		for _, v := range in.Status {
			values.Add("status", fmt.Sprintf("%s", v))
		}
		for _, v := range in.Target {
			values.Add("target", fmt.Sprintf("%s", v))
		}
		for _, v := range in.Description {
			values.Add("description", fmt.Sprintf("%s", v))
		}

		u := url.URL{
			Path:     fmt.Sprintf("/lastjobs"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_GetLastJobs_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_OverloadService_GetJobParams_0 = "/job_params"

	pattern_goclay_OverloadService_GetJobParams_0_builder = func(in *GetJobParamsRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/job_params"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_GetJobParams_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_OverloadService_UpdateJob_0 = "/update_job"

	pattern_goclay_OverloadService_UpdateJob_0_builder = func(in *UpdateJobRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/update_job"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_UpdateJob_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_DeleteJob_0 = "/delete_job"

	pattern_goclay_OverloadService_DeleteJob_0_builder = func(in *DeleteJobRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/delete_job"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_DeleteJob_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_CreateAggregates_0 = "/upload_aggregates"

	pattern_goclay_OverloadService_CreateAggregates_0_builder = func(in *CreateAggregatesRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/upload_aggregates"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_CreateAggregates_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_GetAggregates_0 = "/aggregates/{test_id}"

	pattern_goclay_OverloadService_GetAggregates_0_builder = func(in *GetAggregatesRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/aggregates/%v", in.TestId),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_GetAggregates_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"test_id": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_GetCollections_0 = "/collections"

	pattern_goclay_OverloadService_GetCollections_0_builder = func(in *GetCollectionsRequest) string {
		values := url.Values{}
		for _, v := range in.Page {
			values.Add("page", fmt.Sprintf("%s", v))
		}
		for _, v := range in.Limit {
			values.Add("limit", fmt.Sprintf("%s", v))
		}
		for _, v := range in.CollectionId {
			values.Add("collection_id", fmt.Sprintf("%d", v))
		}
		for _, v := range in.Env {
			values.Add("env", fmt.Sprintf("%s", v))
		}
		for _, v := range in.Project {
			values.Add("project", fmt.Sprintf("%s", v))
		}
		for _, v := range in.Ref {
			values.Add("ref", fmt.Sprintf("%s", v))
		}
		for _, v := range in.Name {
			values.Add("name", fmt.Sprintf("%s", v))
		}

		u := url.URL{
			Path:     fmt.Sprintf("/collections"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_GetCollections_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_OverloadService_GetCollectionParams_0 = "/collection_params"

	pattern_goclay_OverloadService_GetCollectionParams_0_builder = func(in *GetCollectionParamsRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/collection_params"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_GetCollectionParams_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_OverloadService_UploadAmmo_0 = "/upload_ammo"

	pattern_goclay_OverloadService_UploadAmmo_0_builder = func(in *UploadAmmoRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/upload_ammo"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_UploadAmmo_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_ListAmmo_0 = "/list_ammo"

	pattern_goclay_OverloadService_ListAmmo_0_builder = func(in *ListAmmoRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/list_ammo"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_ListAmmo_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_OverloadService_DeleteAmmo_0 = "/delete_ammo"

	pattern_goclay_OverloadService_DeleteAmmo_0_builder = func(in *DeleteAmmoRequest) string {
		values := url.Values{}
		values.Add("key", fmt.Sprintf("%s", in.Key))

		u := url.URL{
			Path:     fmt.Sprintf("/delete_ammo"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_DeleteAmmo_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_OverloadService_UploadArtifact_0 = "/upload_artifact"

	pattern_goclay_OverloadService_UploadArtifact_0_builder = func(in *UploadArtifactRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/upload_artifact"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_UploadArtifact_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_ListArtifacts_0 = "/list_artifacts/{job}"

	pattern_goclay_OverloadService_ListArtifacts_0_builder = func(in *ListArtifactsRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/list_artifacts/%v", in.Job),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_ListArtifacts_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"job": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_ListJoints_0 = "/list_joints"

	pattern_goclay_OverloadService_ListJoints_0_builder = func(in *ListJointsRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/list_joints"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_ListJoints_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}

	pattern_goclay_OverloadService_GetJoint_0 = "/joint/{id}"

	pattern_goclay_OverloadService_GetJoint_0_builder = func(in *GetJointRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/joint/%v", in.Id),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_GetJoint_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"id": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_CreateJoint_0 = "/create_joint"

	pattern_goclay_OverloadService_CreateJoint_0_builder = func(in *CreateJointRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/create_joint"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_CreateJoint_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_FirestarterValidate_0 = "/firestarter/validate"

	pattern_goclay_OverloadService_FirestarterValidate_0_builder = func(in *FirestarterValidateRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/firestarter/validate"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_FirestarterValidate_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_FirestarterPrepare_0 = "/firestarter/prepare"

	pattern_goclay_OverloadService_FirestarterPrepare_0_builder = func(in *FirestarterPrepareRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/firestarter/prepare"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_FirestarterPrepare_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_FirestarterRun_0 = "/firestarter/run"

	pattern_goclay_OverloadService_FirestarterRun_0_builder = func(in *FirestarterRunRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/firestarter/run"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_FirestarterRun_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_FirestarterStop_0 = "/firestarter/stop"

	pattern_goclay_OverloadService_FirestarterStop_0_builder = func(in *FirestarterStopRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/firestarter/stop"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_FirestarterStop_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_FirestarterPoll_0 = "/firestarter/poll"

	pattern_goclay_OverloadService_FirestarterPoll_0_builder = func(in *FirestarterPollRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/firestarter/poll"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_FirestarterPoll_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_OverloadService_FirestarterTankSessions_0 = "/firestarter/tank_sessions"

	pattern_goclay_OverloadService_FirestarterTankSessions_0_builder = func(in *FirestarterTankSessionsRequest) string {
		values := url.Values{}
		values.Add("tank", fmt.Sprintf("%s", in.Tank))

		u := url.URL{
			Path:     fmt.Sprintf("/firestarter/tank_sessions"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_OverloadService_FirestarterTankSessions_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
)

// marshalers for OverloadService
var (
	unmarshaler_goclay_OverloadService_CreateJob_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*CreateJobRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_CreateJob_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_GetJob_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*JobRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_GetJob_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			rctx := chi.RouteContext(r.Context())
			if rctx == nil {
				panic("Only chi router is supported for GETs atm")
			}
			for pos, k := range rctx.URLParams.Keys {
				if err := errors.Wrapf(runtime.PopulateFieldFromPath(req, k, rctx.URLParams.Values[pos]), "can't read '%v' from path", k); err != nil {
					return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
				}
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_GetLastJobs_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*LastJobsRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_GetLastJobs_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_GetJobParams_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*GetJobParamsRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_GetJobParams_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_UpdateJob_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*UpdateJobRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_UpdateJob_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_DeleteJob_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*DeleteJobRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_DeleteJob_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_CreateAggregates_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*CreateAggregatesRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_CreateAggregates_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_GetAggregates_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*GetAggregatesRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_GetAggregates_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			rctx := chi.RouteContext(r.Context())
			if rctx == nil {
				panic("Only chi router is supported for GETs atm")
			}
			for pos, k := range rctx.URLParams.Keys {
				if err := errors.Wrapf(runtime.PopulateFieldFromPath(req, k, rctx.URLParams.Values[pos]), "can't read '%v' from path", k); err != nil {
					return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
				}
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_GetCollections_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*GetCollectionsRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_GetCollections_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_GetCollectionParams_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*GetCollectionParamsRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_GetCollectionParams_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_UploadAmmo_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*UploadAmmoRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_UploadAmmo_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_ListAmmo_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*ListAmmoRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_ListAmmo_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_DeleteAmmo_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*DeleteAmmoRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_DeleteAmmo_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_UploadArtifact_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*UploadArtifactRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_UploadArtifact_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_ListArtifacts_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*ListArtifactsRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_ListArtifacts_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			rctx := chi.RouteContext(r.Context())
			if rctx == nil {
				panic("Only chi router is supported for GETs atm")
			}
			for pos, k := range rctx.URLParams.Keys {
				if err := errors.Wrapf(runtime.PopulateFieldFromPath(req, k, rctx.URLParams.Values[pos]), "can't read '%v' from path", k); err != nil {
					return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
				}
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_ListJoints_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*ListJointsRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_ListJoints_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_GetJoint_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*GetJointRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_GetJoint_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			rctx := chi.RouteContext(r.Context())
			if rctx == nil {
				panic("Only chi router is supported for GETs atm")
			}
			for pos, k := range rctx.URLParams.Keys {
				if err := errors.Wrapf(runtime.PopulateFieldFromPath(req, k, rctx.URLParams.Values[pos]), "can't read '%v' from path", k); err != nil {
					return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
				}
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_CreateJoint_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*CreateJointRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_CreateJoint_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_FirestarterValidate_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*FirestarterValidateRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_FirestarterValidate_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_FirestarterPrepare_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*FirestarterPrepareRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_FirestarterPrepare_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_FirestarterRun_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*FirestarterRunRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_FirestarterRun_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_FirestarterStop_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*FirestarterStopRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_FirestarterStop_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_FirestarterPoll_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*FirestarterPollRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_FirestarterPoll_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_OverloadService_FirestarterTankSessions_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*FirestarterTankSessionsRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_OverloadService_FirestarterTankSessions_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			return nil
		}
	}
)

var _swaggerDef_overload_proto = []byte(`{
  "swagger": "2.0",
  "info": {
    "title": "overload.proto",
    "version": "version not set"
  },
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/aggregates/{test_id}": {
      "get": {
        "operationId": "GetAggregates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/GetAggregatesResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "test_id",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/collection_params": {
      "get": {
        "operationId": "GetCollectionParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/GetCollectionParamsResponse"
            }
          }
        },
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/collections": {
      "get": {
        "operationId": "GetCollections",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/GetCollectionsResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "collection_id",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "env",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "project",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "ref",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "name",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/create_job": {
      "post": {
        "summary": "Jobs",
        "operationId": "CreateJob",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/CreateJobResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateJobRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/create_joint": {
      "post": {
        "operationId": "CreateJoint",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/CreateJointResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateJointRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/delete_ammo": {
      "get": {
        "operationId": "DeleteAmmo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/DeleteAmmoResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "key",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/delete_job": {
      "post": {
        "operationId": "DeleteJob",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/DeleteJobResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/DeleteJobRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/firestarter/poll": {
      "post": {
        "operationId": "FirestarterPoll",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/FirestarterPollResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/FirestarterPollRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/firestarter/prepare": {
      "post": {
        "operationId": "FirestarterPrepare",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/FirestarterPrepareResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/FirestarterPrepareRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/firestarter/run": {
      "post": {
        "operationId": "FirestarterRun",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/FirestarterRunResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/FirestarterRunRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/firestarter/stop": {
      "post": {
        "operationId": "FirestarterStop",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/FirestarterStopResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/FirestarterStopRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/firestarter/tank_sessions": {
      "get": {
        "operationId": "FirestarterTankSessions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/FirestarterTankSessionsResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "tank",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/firestarter/validate": {
      "post": {
        "operationId": "FirestarterValidate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/FirestarterValidateResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/FirestarterValidateRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/job/{id}": {
      "get": {
        "operationId": "GetJob",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/JobResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/job_params": {
      "get": {
        "operationId": "GetJobParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/GetJobParamsResponse"
            }
          }
        },
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/joint/{id}": {
      "get": {
        "operationId": "GetJoint",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/GetJointResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/lastjobs": {
      "get": {
        "operationId": "GetLastJobs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/LastJobsResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "author",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "target",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "name": "description",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/list_ammo": {
      "get": {
        "operationId": "ListAmmo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ListAmmoResponse"
            }
          }
        },
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/list_artifacts/{job}": {
      "get": {
        "operationId": "ListArtifacts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ListArtifactsResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "job",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/list_joints": {
      "get": {
        "summary": "Joints",
        "operationId": "ListJoints",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/ListJointsResponse"
            }
          }
        },
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/update_job": {
      "post": {
        "operationId": "UpdateJob",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/UpdateJobResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/UpdateJobRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/upload_aggregates": {
      "post": {
        "summary": "Aggregates",
        "operationId": "CreateAggregates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/CreateAggregatesResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateAggregatesRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/upload_ammo": {
      "post": {
        "summary": "Ammo",
        "operationId": "UploadAmmo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/UploadAmmoResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/UploadAmmoRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    },
    "/upload_artifact": {
      "post": {
        "summary": "Artifacts",
        "operationId": "UploadArtifact",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/UploadArtifactResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/UploadArtifactRequest"
            }
          }
        ],
        "tags": [
          "OverloadService"
        ]
      }
    }
  },
  "definitions": {
    "Ammo": {
      "type": "object",
      "properties": {
        "etag": {
          "type": "string"
        },
        "key": {
          "type": "string"
        },
        "lastModified": {
          "type": "string"
        },
        "lastUsed": {
          "type": "number",
          "format": "double"
        },
        "author": {
          "type": "string"
        },
        "size": {
          "type": "string",
          "format": "int64"
        },
        "path": {
          "type": "string"
        },
        "type": {
          "type": "string"
        }
      }
    },
    "Artifact": {
      "type": "object",
      "properties": {
        "etag": {
          "type": "string"
        },
        "key": {
          "type": "string"
        },
        "lastModified": {
          "type": "string"
        },
        "size": {
          "type": "string",
          "format": "int64"
        },
        "path": {
          "type": "string"
        },
        "job": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "Collection": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int32"
        },
        "env": {
          "type": "string"
        },
        "project": {
          "type": "string"
        },
        "service": {
          "type": "string"
        },
        "ref": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "author": {
          "type": "string"
        },
        "type": {
          "type": "string"
        },
        "latestJobs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Job"
          }
        }
      }
    },
    "CreateAggregatesRequest": {
      "type": "object",
      "properties": {
        "label": {
          "type": "string"
        },
        "q50": {
          "type": "number",
          "format": "float"
        },
        "q75": {
          "type": "number",
          "format": "float"
        },
        "q80": {
          "type": "number",
          "format": "float"
        },
        "q85": {
          "type": "number",
          "format": "float"
        },
        "q90": {
          "type": "number",
          "format": "float"
        },
        "q95": {
          "type": "number",
          "format": "float"
        },
        "q98": {
          "type": "number",
          "format": "float"
        },
        "q99": {
          "type": "number",
          "format": "float"
        },
        "q100": {
          "type": "number",
          "format": "float"
        },
        "avg": {
          "type": "number",
          "format": "float"
        },
        "responseCode": {
          "type": "string"
        },
        "okCount": {
          "type": "string",
          "format": "int64"
        },
        "errCount": {
          "type": "string",
          "format": "int64"
        },
        "netRecv": {
          "type": "number",
          "format": "float"
        },
        "netSend": {
          "type": "number",
          "format": "float"
        },
        "jobId": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "CreateAggregatesResponse": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "CreateJobRequest": {
      "type": "object",
      "properties": {
        "testStart": {
          "type": "number",
          "format": "double"
        },
        "testStop": {
          "type": "number",
          "format": "double"
        },
        "config": {
          "type": "string"
        },
        "author": {
          "type": "string"
        },
        "regressionId": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "tank": {
          "type": "string"
        },
        "target": {
          "type": "string"
        },
        "environmentDetails": {
          "type": "string"
        },
        "collections": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Collection"
          }
        }
      }
    },
    "CreateJobResponse": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "CreateJointRequest": {
      "type": "object",
      "properties": {
        "jobs": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        },
        "name": {
          "type": "string"
        }
      }
    },
    "CreateJointResponse": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "DeleteAmmoResponse": {
      "type": "object"
    },
    "DeleteJobRequest": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "DeleteJobResponse": {
      "type": "object"
    },
    "FirestarterPollRequest": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "FirestarterPollResponse": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "FirestarterPrepareRequest": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "FirestarterPrepareResponse": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "FirestarterRunRequest": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "FirestarterRunResponse": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "FirestarterStopRequest": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "FirestarterStopResponse": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "FirestarterTankSessionsResponse": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "FirestarterValidateRequest": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "FirestarterValidateResponse": {
      "type": "object",
      "properties": {
        "sessions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TankSession"
          }
        }
      }
    },
    "GetAggregatesResponse": {
      "type": "object",
      "properties": {
        "aggregates": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/JobAggregate"
          }
        }
      }
    },
    "GetCollectionParamsResponse": {
      "type": "object",
      "properties": {
        "envs": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "projects": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Project"
          }
        },
        "refs": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "names": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "GetCollectionsResponse": {
      "type": "object",
      "properties": {
        "collections": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Collection"
          }
        },
        "count": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "GetJobParamsResponse": {
      "type": "object",
      "properties": {
        "authors": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "statuses": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "targets": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "GetJointResponse": {
      "type": "object",
      "properties": {
        "joint": {
          "$ref": "#/definitions/Joint"
        }
      }
    },
    "Job": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int32"
        },
        "testStart": {
          "type": "number",
          "format": "double"
        },
        "testStop": {
          "type": "number",
          "format": "double"
        },
        "config": {
          "type": "string"
        },
        "author": {
          "type": "string"
        },
        "regressionId": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "tank": {
          "type": "string"
        },
        "target": {
          "type": "string"
        },
        "environmentDetails": {
          "type": "string"
        },
        "status": {
          "type": "string"
        },
        "autostopTime": {
          "type": "number",
          "format": "double"
        },
        "autostopMessage": {
          "type": "string"
        },
        "imbalance": {
          "type": "integer",
          "format": "int32"
        },
        "collections": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Collection"
          }
        }
      }
    },
    "JobAggregate": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int32"
        },
        "label": {
          "type": "string"
        },
        "q50": {
          "type": "number",
          "format": "float"
        },
        "q75": {
          "type": "number",
          "format": "float"
        },
        "q80": {
          "type": "number",
          "format": "float"
        },
        "q85": {
          "type": "number",
          "format": "float"
        },
        "q90": {
          "type": "number",
          "format": "float"
        },
        "q95": {
          "type": "number",
          "format": "float"
        },
        "q98": {
          "type": "number",
          "format": "float"
        },
        "q99": {
          "type": "number",
          "format": "float"
        },
        "q100": {
          "type": "number",
          "format": "float"
        },
        "avg": {
          "type": "number",
          "format": "float"
        },
        "responseCode": {
          "type": "string"
        },
        "okCount": {
          "type": "string",
          "format": "int64"
        },
        "errCount": {
          "type": "string",
          "format": "int64"
        },
        "netRecv": {
          "type": "number",
          "format": "float"
        },
        "netSend": {
          "type": "number",
          "format": "float"
        },
        "jobId": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "JobResponse": {
      "type": "object",
      "properties": {
        "job": {
          "$ref": "#/definitions/Job"
        }
      }
    },
    "Joint": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int32"
        },
        "jobs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Job"
          }
        },
        "name": {
          "type": "string"
        }
      }
    },
    "LastJobsResponse": {
      "type": "object",
      "properties": {
        "jobs": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Job"
          }
        },
        "count": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "ListAmmoResponse": {
      "type": "object",
      "properties": {
        "ammo": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Ammo"
          }
        }
      }
    },
    "ListArtifactsResponse": {
      "type": "object",
      "properties": {
        "artifacts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Artifact"
          }
        }
      }
    },
    "ListJointsResponse": {
      "type": "object",
      "properties": {
        "joints": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Joint"
          }
        }
      }
    },
    "Project": {
      "type": "object",
      "properties": {
        "project": {
          "type": "string"
        },
        "service": {
          "type": "string"
        }
      }
    },
    "TankSession": {
      "type": "object",
      "properties": {
        "tank": {
          "type": "string"
        },
        "conf": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "failures": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "stage": {
          "type": "string"
        },
        "status": {
          "type": "string"
        },
        "externalId": {
          "type": "string"
        },
        "overloadId": {
          "type": "integer",
          "format": "int32"
        },
        "externalJoint": {
          "type": "string"
        },
        "overloadJoint": {
          "type": "integer",
          "format": "int32"
        },
        "author": {
          "type": "string"
        }
      }
    },
    "UpdateJobRequest": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int32"
        },
        "testStart": {
          "type": "number",
          "format": "double"
        },
        "testStop": {
          "type": "number",
          "format": "double"
        },
        "config": {
          "type": "string"
        },
        "author": {
          "type": "string"
        },
        "regressionId": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "tank": {
          "type": "string"
        },
        "target": {
          "type": "string"
        },
        "environmentDetails": {
          "type": "string"
        },
        "status": {
          "type": "string"
        },
        "autostopTime": {
          "type": "number",
          "format": "double"
        },
        "autostopMessage": {
          "type": "string"
        },
        "imbalance": {
          "type": "integer",
          "format": "int32"
        },
        "collections": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "UpdateJobResponse": {
      "type": "object"
    },
    "UploadAmmoRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "file": {
          "type": "string"
        }
      }
    },
    "UploadAmmoResponse": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string"
        }
      }
    },
    "UploadArtifactRequest": {
      "type": "object",
      "properties": {
        "job": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "file": {
          "type": "string"
        }
      }
    },
    "UploadArtifactResponse": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string"
        }
      }
    }
  }
}

`)
